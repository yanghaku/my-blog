{"meta":{"title":"YangBo","subtitle":"奋斗才能拥有最美丽的人生","description":"一个快废掉的咸鱼罢了","author":"杨博","url":"https://yanghaku.github.io","root":"/"},"pages":[{"title":"about the author of this blog","date":"2019-05-17T05:29:39.000Z","updated":"2019-05-20T16:04:29.000Z","comments":false,"path":"about/index.html","permalink":"https://yanghaku.github.io/about/index.html","excerpt":"","text":"github: yanghaku qq: 1961882079 school: neu"},{"title":"categories","date":"2019-05-20T16:01:56.000Z","updated":"2019-05-20T16:04:45.000Z","comments":false,"path":"categories/index.html","permalink":"https://yanghaku.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-20T16:05:36.000Z","updated":"2019-05-20T16:05:59.000Z","comments":false,"path":"tags/index.html","permalink":"https://yanghaku.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基于内容的个性化推荐系统设计与实现","slug":"基于内容的个性化推荐系统","date":"2020-02-12T03:22:00.000Z","updated":"2020-02-13T08:03:12.578Z","comments":true,"path":"2020/02/12/基于内容的个性化推荐系统/","link":"","permalink":"https://yanghaku.github.io/2020/02/12/%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/","excerpt":"因为项目的需要，里面加一个小型的推荐系统的模块，就找了一些资料，实现了基于内容的一个推荐系统。 原理基于内容相似度的推荐：就是把与你喜欢看的文章内容相似的文章推荐给你。 优势：无冷启动的问题，只要用户产生了初始的历史数据，就可以开始进行推荐计算。而且随着用户的浏览记录数据的增加，这种推荐一般也会越来越准确。","text":"因为项目的需要，里面加一个小型的推荐系统的模块，就找了一些资料，实现了基于内容的一个推荐系统。 原理基于内容相似度的推荐：就是把与你喜欢看的文章内容相似的文章推荐给你。 优势：无冷启动的问题，只要用户产生了初始的历史数据，就可以开始进行推荐计算。而且随着用户的浏览记录数据的增加，这种推荐一般也会越来越准确。 判断两篇内容相似用TFIDF 算法，提取出每篇新闻的 (关键词,TFIDF值) 词数对 TFIDF 计算：首先分词 然后词频： 词频（TF） = \\frac{某个词在文章出现次数}{文章总词数}逆文档频率（需要一个语料库） 逆文档频率（IDF） = \\log(\\frac{语料库中的文档数}{包含该词的文档数+1})最后： TFIDF = TF * IDFTF-IDF与一个词在文档中的出现次数成正比，与该词在整个语言中的出现次数成反比，反应了这个词在文章中的重要程度。 两篇文章的相似度就可以利用余弦定理来算： Similarity(A,B) = \\frac{\\sum_{i\\in A\\cap B} TFIDF_A[i] * TFIDF_B[i] }{ \\sqrt{\\sum{TFIDF_A[i]*TFIDF_A[i]}} + \\sqrt{\\sum{TFIDF_B[i]*TFIDF_B[i]}} }构建用户的喜好关键：维护用户喜好的关键词表 ，维护 (关键词, 喜好程度) 键值对 获得：根据用户的点赞、收藏记录 做法： 用户浏览了某个文章，利用TF-IDF 取得这篇文章的 （关键词,IFIDF值）键值对，并将这个存入用户的喜好关键词列表中。（如果已经有了，那就将值叠加，表示用以加强用户对该关键词的感兴趣程度） 考虑的问题：用户喜好会不会不断更新？会不会导致推荐结果收敛到用户以前特别喜欢的几个关键词上？ 考虑到这个问题，可以为关键词列表设置一个衰减系数 $\\lambda$ , 定期对用户的所有TFIDF值进行更新衰减，减少关键词的收敛倾向。 用户的喜好与内容的匹配程度计算有了用户的喜好关键词表： { keyword1:val1, keyword2:val2,………} 某条文章的关键词表： {keyword1: val1, keyword2: val2,………} 用户的喜好表也看作一篇文章，两者的匹配值也是用余弦定理（上面的similarity）来计算。 对所有新的文章进行计算，将拟合度最高的N个推荐给用户 如果可推荐的太少：为用户设定一个文章推荐的最小值 N， 若不够 N ， 就用热点（近期被点击最多的文章）作为补充 架构令维护三个数据表： 文章的关键词表 article_keyword 用户喜爱的关键词表 user_keyword 用户推荐的文章表 article_recommend 设定更新周期（比如1天），那么可以在每日凌晨某一时刻的时候进行： 将最近1天更新的所有文章分析，更新其关键词表 将用户的喜好关键词表进行时间的衰减 然后将最近1天的收藏记录和点赞记录，更新有活动记录用户的关键词表 最后更新有活动记录用户推荐的文章表 实现1.定时任务首先增加 “spring-task.xml” 配置文件，配置spring的定时任务 在web.xml 增加这个配置文件1234567&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:spring-mybatis.xml classpath:spring-task.xml &lt;!-- 增加的值 --&gt; &lt;/param-value&gt; &lt;/context-param&gt; 编辑spring-task.xml 文件，使其支持注解 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.0.xsd\"&gt; &lt;!-- 配置spring 定时任务的配置文件 --&gt; &lt;!--配置包扫描--&gt; &lt;context:component-scan base-package=\"edu.study.util.timer\" /&gt; &lt;!-- 定时任务配置 scheduler 方式 注解 --&gt; &lt;task:executor id=\"executor\" pool-size=\"5\"/&gt; &lt;task:scheduler id=\"scheduler\" pool-size=\"10\"/&gt;&lt;!-- 配置线程池--&gt; &lt;task:annotation-driven executor=\"executor\" scheduler=\"scheduler\"/&gt;&lt;/beans&gt; 然后在 edu.study.util 里面新建一个包 timer ， 在timer包内增加TimerJob 类 TimerJob.java:(其中里面用的ContentBaseRecommend类就是将要实现的关键类) 1234567891011121314151617181920212223package edu.study.util.timer;import edu.study.util.recommend.ContentBasedRecommend;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.util.Date;@Componentpublic class TimerJob &#123; /** * 定时任务的类 */ @Autowired ContentBasedRecommend contentBasedRecommend; @Scheduled(cron = \"0 0/2 * * * ?\")//每隔2分钟执行一次 public void recommendRefresh()&#123; // 刷新上次更新至今这个时间段的推荐 contentBasedRecommend.refresh(); &#125;&#125; 2.基于内容的推荐算法实现(为了省事，全部写在了一个类里面) 新建一个包 edu.study.util.recommend然后新建一个类 ContentBasedRecommend.javaContentBasedRecommend.java（具体实现看代码和注释）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317package edu.study.util.recommend;import edu.study.dao.*;import edu.study.model.*;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.util.*;@Componentpublic class ContentBasedRecommend &#123; // 需要用到的数据库服务 @Autowired ArticleMapper articleMapper; @Autowired ArticleAgreeMapper articleAgreeMapper; @Autowired ArticleCollectionMapper articleCollectionMapper; @Autowired ArticleKeywordMapper articleKeywordMapper; @Autowired UserKeywordMapper userKeywordMapper; @Autowired ArticleRecommendMapper articleRecommendMapper; private Date lastRefreshDate;//维护上次更新的时间 private static final int ARTICLE_KEYWORD_MAX_NUM = 100;// 设置一个文章的关键词上限 private static final int USER_KEYWORD_MAX_NUM = 1000;//设置存储的用户关键词的上限 private static final int RECOMMEND_NUM = 20; // 设置每个用户推荐的文章个数 private static final double AUTO_DEC_NUM = 0.9; //设置每天衰减的系数 private static final double lambda = 1.5; //设置收藏的权重 对于 点赞的权重的倍数 /** *根据lastrefreshTime ~ 至今 这个时间段的活动记录，刷新推荐 * 并将lastrefreshTime 更新到现在 * */ public void refresh()&#123; if(lastRefreshDate == null)&#123;//如果上次更新时间没有实例化，那就创建一个最早的时间 lastRefreshDate = new Date(); lastRefreshDate.setTime(0); &#125; System.err.println(\"last time: \" + lastRefreshDate); Date nowRefreshTime = new Date();//本次的更新时间 System.err.println(\"now: \"+ nowRefreshTime); // 1. 将时间段内更新的文章的关键词更新 articleKeywordRefresh(); // 2. 根据两次时间差，将所有用户的喜好衰减更新 userKeywordAutoDec(lastRefreshDate,nowRefreshTime); // 3. 根据时间段内的活动记录，将活动的用户的关键词更新 HashMap&lt;String,HashMap&lt;String,Double&gt; &gt; usersKeyword = userKeywordRefresh(); if(usersKeyword.size() == 0)&#123;// 如果这段时间没有产生用户行为，就直接退出 lastRefreshDate = nowRefreshTime; return; &#125; List&lt;ArticleKeyword&gt; articleKeywordList = articleKeywordMapper.selectAll(); // 预处理所有的文章的关键词保存下来 HashMap&lt;Integer,List&lt;Keyword&gt; &gt;articleKeyword = new HashMap&lt;&gt;(); for(ArticleKeyword item : articleKeywordList)&#123; if(articleKeyword.containsKey(item.getArticleId()))&#123; articleKeyword.get(item.getArticleId()).add(new Keyword(item.getKeyword(),item.getTfidf())); &#125; else&#123; List&lt;Keyword&gt; keywordList = new ArrayList&lt;&gt;(); keywordList.add(new Keyword(item.getKeyword(),item.getTfidf())); articleKeyword.put(item.getArticleId(),keywordList); &#125; &#125; articleKeywordList.clear(); // 预处理出来 每个关键词列表的 平方和的平方根 （余弦定理的分母部分） HashMap&lt;String,Double&gt; userDiv = new HashMap&lt;&gt;(); HashMap&lt;Integer,Double&gt; articleDiv = new HashMap&lt;&gt;(); for(Map.Entry&lt;String,HashMap&lt;String,Double&gt;&gt; entry: usersKeyword.entrySet())&#123; double sum=0; for(Double val: entry.getValue().values())&#123; sum += val*val; &#125; userDiv.put(entry.getKey(),Math.sqrt(sum)); &#125; for(Map.Entry&lt;Integer,List&lt;Keyword&gt; &gt; entry: articleKeyword.entrySet())&#123; double sum=0; for(Keyword x : entry.getValue())&#123; sum += x.getTfidf() * x.getTfidf(); &#125; articleDiv.put(entry.getKey(),Math.sqrt(sum)); &#125; List&lt;ArticleRecommend&gt; articleRecommends = new ArrayList&lt;&gt;(); //开始推荐计算 for(Map.Entry&lt;String,HashMap&lt;String,Double&gt; &gt; userEntry: usersKeyword.entrySet())&#123; //外层循环遍历每个用户 articleRecommends.clear(); for(Map.Entry&lt;Integer,List&lt;Keyword&gt;&gt; articleEntry: articleKeyword.entrySet())&#123; //内层循环遍历每篇文章 double score = similarity(userEntry.getValue(),articleEntry.getValue()); if(score &gt; 0.00001)&#123;// 非零就加入推荐列表里 score /= (userDiv.get(userEntry.getKey()) * articleDiv.get(articleEntry.getKey())); articleRecommends.add(new ArticleRecommend(userEntry.getKey(),articleEntry.getKey(),score)); &#125; &#125; // 删除数据库中原先的推荐信息 articleRecommendMapper.deleteByUsername(userEntry.getKey()); // 如果推荐的列表大于需要推荐的个数，就排序，添加前面推荐值高的 // 保存到数据库中 if(articleRecommends.isEmpty())continue; if(articleRecommends.size() &gt; RECOMMEND_NUM)&#123; sortRecommendList(articleRecommends); articleRecommendMapper.insertList(articleRecommends.subList(0,RECOMMEND_NUM)); &#125; else articleRecommendMapper.insertList(articleRecommends); &#125; // 最后将lastRefreshTime 更新成本次更新的时间 lastRefreshDate = nowRefreshTime; &#125; /** * 将lastrefreshTime ~ 至今 时间段的文章的关键词更新 */ private void articleKeywordRefresh()&#123; List&lt;Article&gt; articleList = articleMapper.selectByModifyTime(lastRefreshDate); for(Article article : articleList)&#123; // 对于每个文章，分析出关键词列表 List&lt;Keyword&gt; keywordList = TFIDF.getTFIDF(article.getTitle(),article.getContent(),ARTICLE_KEYWORD_MAX_NUM,articleMapper); // 使用sql批量修改 if(!keywordList.isEmpty())articleKeywordMapper.replaceInto(article.getArticleId(),keywordList); &#125; &#125; /** *根据规定时间段的活动记录，将用户的关键词更新 * 并且将涉及到的用户更新后的值返回（以便为这些用户推荐） */ private HashMap&lt;String,HashMap&lt;String,Double&gt; &gt; userKeywordRefresh()&#123; // 分为两部分：收藏的文章 和 点赞的文章 // 其中收藏的文章的权重为点赞的文章的 lambda 倍 HashMap&lt;String,HashMap&lt;String,Double&gt; &gt; record = new HashMap&lt;&gt;(); // 记录涉及到的每个用户的keyword表，最后一起更新到数据库 // 处理过程中keyword 保存为hashmap ，便于合并（降低查找复杂度） // 1. 文章收藏 List&lt;ArticleCollection&gt; articleCollectionList = articleCollectionMapper.selectByTime(lastRefreshDate); if(articleCollectionList != null) &#123; for (ArticleCollection articleCollection : articleCollectionList) &#123; List&lt;Keyword&gt; articleKeywordList = articleKeywordMapper.selectByArticleId(articleCollection.getArticleId()); if(articleKeywordList == null || articleKeywordList.isEmpty())continue; if (record.containsKey(articleCollection.getUsername())) &#123; // 如果已经有了就合并 HashMap&lt;String,Double&gt; tmp = record.get(articleCollection.getUsername()); for(Keyword articleKeyword: articleKeywordList)&#123; if(tmp.containsKey(articleKeyword.getKeyword())) &#123; tmp.put(articleKeyword.getKeyword(), tmp.get(articleKeyword.getKeyword()) + articleKeyword.getTfidf() * lambda); &#125; else tmp.put(articleKeyword.getKeyword(),articleKeyword.getTfidf()*lambda); &#125; record.put(articleCollection.getUsername(), tmp); &#125; else&#123; HashMap&lt;String,Double&gt; tmp = new HashMap&lt;&gt;(); for(Keyword articleKeyword: articleKeywordList)&#123; tmp.put(articleKeyword.getKeyword(),articleKeyword.getTfidf()*lambda); &#125; record.put(articleCollection.getUsername(), tmp); &#125; &#125; &#125; // 2. 文章点赞 List&lt;ArticleAgree&gt; articleAgreeList = articleAgreeMapper.selectByTime(lastRefreshDate); if(articleAgreeList != null) &#123; for (ArticleAgree articleAgree : articleAgreeList) &#123; List&lt;Keyword&gt; articleKeywordList = articleKeywordMapper.selectByArticleId(articleAgree.getArticleId()); if(articleKeywordList == null || articleKeywordList.isEmpty())continue; if (record.containsKey(articleAgree.getUsername())) &#123; // 如果已经有了就合并 HashMap&lt;String,Double&gt; tmp = record.get(articleAgree.getUsername()); for(Keyword articleKeyword: articleKeywordList)&#123; if(tmp.containsKey(articleKeyword.getKeyword())) &#123; tmp.put(articleKeyword.getKeyword(), tmp.get(articleKeyword.getKeyword()) + articleKeyword.getTfidf()); &#125; else tmp.put(articleKeyword.getKeyword(),articleKeyword.getTfidf()); &#125; record.put(articleAgree.getUsername(), tmp); &#125; else&#123; HashMap&lt;String,Double&gt; tmp = new HashMap&lt;&gt;(); for(Keyword articleKeyword: articleKeywordList)&#123; tmp.put(articleKeyword.getKeyword(),articleKeyword.getTfidf()); &#125; record.put(articleAgree.getUsername(), tmp); &#125; &#125; &#125; // 将增加的关键词 与 用户原先的合并 // 然后将更新的键值 保存到数据库中 for(HashMap.Entry&lt;String,HashMap&lt;String,Double&gt; &gt; entry : record.entrySet())&#123; List&lt;Keyword&gt; userKeywordList = userKeywordMapper.selectByUsername(entry.getKey()); if(userKeywordList != null) &#123; for (Keyword keyword : userKeywordList) &#123; // 如果已经有就合并 if (entry.getValue().containsKey(keyword.getKeyword())) &#123; entry.getValue().put(keyword.getKeyword(), entry.getValue().get(keyword.getKeyword()) + keyword.getTfidf()); &#125; else entry.getValue().put(keyword.getKeyword(), keyword.getTfidf()); &#125; &#125; //将每个用户对应的关键词的map 以列表的形式存下来(方便插入数据库) if(userKeywordList != null )userKeywordList.clear(); else userKeywordList = new ArrayList&lt;&gt;(); for(HashMap.Entry&lt;String,Double&gt; keyWordEntry: entry.getValue().entrySet())&#123; userKeywordList.add(new Keyword(keyWordEntry.getKey(),keyWordEntry.getValue())); &#125; if(userKeywordList.isEmpty())continue; if(userKeywordList.size() &gt; USER_KEYWORD_MAX_NUM) &#123;// 如果超过了规定的数，就删除影响最小的 sortKeyWordList(userKeywordList); while (userKeywordList.size() &gt; USER_KEYWORD_MAX_NUM)&#123; entry.getValue().remove(userKeywordList.get(userKeywordList.size()-1).getKeyword()); userKeywordList.remove(userKeywordList.size()-1); &#125; &#125; // 最后将此保存到数据库中 userKeywordMapper.replaceInto(entry.getKey(),userKeywordList); &#125; return record; &#125; /** * 将关键词列表从大到小排序 * @param keywordList 关键词列表 */ private void sortKeyWordList(List&lt;Keyword&gt; keywordList)&#123; Collections.sort(keywordList, new Comparator&lt;Keyword&gt;() &#123;// 使用内部类自定义排序规则 @Override public int compare(Keyword o1, Keyword o2) &#123; // 按照TFIDF值从大到小排序 if(o2.getTfidf() - o1.getTfidf() &gt; 0)return 1; else if(o2.getTfidf() - o1.getTfidf() == 0)return 0; return -1; &#125; &#125;); &#125; /** * 排序 * @param articleRecommendList 推荐列表 */ private void sortRecommendList(List&lt;ArticleRecommend&gt; articleRecommendList)&#123; Collections.sort(articleRecommendList, new Comparator&lt;ArticleRecommend&gt;() &#123; @Override public int compare(ArticleRecommend o1, ArticleRecommend o2) &#123; if(o2.getSimilarity() - o1.getSimilarity() &gt; 0)return 1; else if(o2.getSimilarity() - o1.getSimilarity() == 0)return 0; return -1; &#125; &#125;); &#125; /** * * @param hashMap 用户的关键词表 * @param keywordList 文章的关键词表 * @return 返回两者的相似度 (余弦定理的上半部分) */ private double similarity(HashMap&lt;String,Double&gt; hashMap,List&lt;Keyword&gt; keywordList)&#123; double ans=0; for(Keyword keyword: keywordList)&#123; if(hashMap.containsKey(keyword.getKeyword()))&#123; ans += keyword.getTfidf() * hashMap.get(keyword.getKeyword()); &#125; &#125; return ans; &#125; /** * 用户的兴趣随时间衰减值 */ public void userKeywordAutoDec(Date from,Date to)&#123; double day = to.getTime() - from.getTime(); day /= (1000 * 60 * 60 * 24 ); //两者相隔的天数 double dec = Math.pow(AUTO_DEC_NUM , day); userKeywordMapper.mulAll(dec); &#125;&#125; 3.TFIDF 算法实现(将分词和TFIDF都写在了一个类里面了) 在包 edu.study.util.recommend 里面新建一个类 TFIDF.java TFIDF需要两个部分： 分词（计算词频），语料库（计算逆文档频率） 分词这里使用的是Stanford CoreNLP， 是由The Stanford Natural LanguageProcessing Group斯坦福大学自然语言处理团队开发的多个NLP工具之一。这个NLP工具非常强大，支持多种编程语言，支持分析多种自然语言，能够进行句法语法分析，远不止分词这点功能。~(这里使用这个工具真的有点大材小用的感觉)~github地址：https://github.com/stanfordnlp/CoreNLP文档地址：https://stanfordnlp.github.io/CoreNLP/index.html 直接使用maven构建工具下载即可，在 “pom.xml” 的&lt;dependencies&gt;节点里面添加： 1234567891011&lt;dependency&gt; &lt;groupId&gt;edu.stanford.nlp&lt;/groupId&gt; &lt;artifactId&gt;stanford-corenlp&lt;/artifactId&gt; &lt;version&gt;3.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;edu.stanford.nlp&lt;/groupId&gt; &lt;artifactId&gt;stanford-corenlp&lt;/artifactId&gt; &lt;version&gt;3.9.2&lt;/version&gt; &lt;classifier&gt;models&lt;/classifier&gt;&lt;/dependency&gt; 这里只加了英文的处理。如果想添加中文或者其他语言的支持，另外再加几个包即可。 主要是使用分词和词性的还原,词性标注 ，比如apples-&gt;apple, created -&gt; create 等然后只将有用的名词，某些动词，形容词，副词等作为关键词（也省去了停顿词的过滤）实现可以看下面的TFIDF.java 中的 cut函数 语料库语料库是个头疼的问题，暂时没有找到，而且每个行业的文本背景不一样，不适合都用通用的IDF语料库，所以就暂时将现有的article数据表当做语料库（这样语料库也是在不断更新扩大中） TFIDF实现其中只提供一个静态接口为推荐算法调用 实现代码 TFIDF.java: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package edu.study.util.recommend;import edu.stanford.nlp.simple.Document;import edu.stanford.nlp.simple.Sentence;import edu.study.dao.ArticleMapper;import edu.study.model.Keyword;import java.util.*;public class TFIDF &#123; public static List&lt;Keyword&gt; getTFIDF(String title, String content, int keywordNum, ArticleMapper articleMapper)&#123; List&lt;String&gt; words = cut(content); words.addAll(cut(title)); int total = words.size();//总词数 HashMap&lt;String,Double&gt; tfidf = new HashMap&lt;&gt;(); // 首先计算词频 TF for(String word:words)&#123; if(tfidf.containsKey(word))&#123; tfidf.put(word,tfidf.get(word)+1); &#125; else tfidf.put(word,1.0); &#125; words.clear();// 不用的马上清空释放内存 for(Map.Entry&lt;String,Double&gt; entry:tfidf.entrySet())&#123; entry.setValue(entry.getValue() / total ); &#125; // 然后计算逆文档频率 double articleTotal = articleMapper.countAll();//总文档个数 for(Map.Entry&lt;String,Double&gt; entry: tfidf.entrySet())&#123; int num = articleMapper.countLike(\"% \"+entry.getKey()+\" %\") + 1;//包含该词的文档数 entry.setValue(entry.getValue() * Math.log(articleTotal/num)); &#125; // 将计算后的保存为Keyword的列表 List&lt;Keyword&gt; keywords = new ArrayList&lt;&gt;(); for(Map.Entry&lt;String,Double&gt; entry: tfidf.entrySet())&#123; keywords.add(new Keyword(entry.getKey(),entry.getValue())); &#125; tfidf.clear();// 不用的清空释放内存 if(keywords.size() &gt; keywordNum)&#123;// 如果大于给定的个数，就排序,取前面重要的 Collections.sort(keywords, new Comparator&lt;Keyword&gt;() &#123; @Override public int compare(Keyword o1, Keyword o2) &#123; double diff = o1.getTfidf() - o2.getTfidf(); if(diff &lt; 0)return 1; else if(diff == 0)return 0; return -1; &#125; &#125;); keywords.subList(keywordNum,keywords.size()).clear();// 将超过的部分删掉 &#125; return keywords; &#125; private static List&lt;String&gt; cut(String content)&#123;// 分词 Document document = new Document(content); List&lt;String&gt; res = new ArrayList&lt;&gt;(); for(Sentence sentence: document.sentences())&#123; // 可作为关键词的词性： 名词，形容词, 动词 // 名词：NN,NNS,NNP（专有名词）,NNPS, NT(时间名词),NP（名词短语），NR（固有名词） FW（外来词） // 形容词：JJ* , 副词： RB* // 动词： VB* int len = sentence.words().size(); for(int i=0;i&lt;len;++i)&#123; String tag = sentence.posTag(i); if(tag.charAt(0)=='N' || tag.contains(\"VB\") || tag.contains(\"FW\") || tag.contains(\"JJ\") || tag.contains(\"RB\"))&#123; // 将词元添加进列表中 res.add(sentence.lemma(i)); &#125; &#125; &#125; return res; &#125;&#125; LAST最后，这个简易的基于内容的推荐系统就算实现了（作为整个系统的一个小模块）因为时间紧，就写了一天的样子吧，也没有具体的测试推荐的效果，可能会有很多的小bug（以后还是有可能维护更新的）具体可以看项目里代码：https://github.com/yanghaku/java-ssm","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://yanghaku.github.io/tags/Spring/"},{"name":"TFIDF","slug":"TFIDF","permalink":"https://yanghaku.github.io/tags/TFIDF/"}]},{"title":"机器学习入门-西瓜书学习笔记（2）模型评估与选择","slug":"周志华机器学习笔记2模型评估与选择","date":"2020-02-07T12:14:00.000Z","updated":"2020-02-12T03:42:12.389Z","comments":true,"path":"2020/02/07/周志华机器学习笔记2模型评估与选择/","link":"","permalink":"https://yanghaku.github.io/2020/02/07/%E5%91%A8%E5%BF%97%E5%8D%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/","excerpt":"","text":"训练误差与过拟合训练误差分类错误的样本数占样本总数的比例称为“错误率”（error rate）。即在m个样本中有a个样本分类错误，则错误率$E = a/m*100% $。相应的，“1-错误率”称为“精度”（accuracy）。更一般地来说，学习器实际预测输出与样本的真实输出之间的差异称为“误差”（error），学习器在训练集上的误差称为“训练误差”（training error）或“经验误差”（empirical error），在新样本上的误差称为“泛化误差”（generalization error）。 过拟合过拟合（overfitting）：把训练样本训练得太好的时候，很可能把训练样本自身的一些特点当做了所有潜在样本都会具有的一般性质，这样导致泛化性能下降。（学习能力太强）欠拟合（underfitting）：与过拟合相对，指对训练样本的一般性质尚未学好。（学习能力太差） 评估方法一般都是通过实验测试的方式来对学习器的泛化误差进行评估，用“测试集”上测得的“测试误差”（testing error）来作为泛化误差的近似。测试集应尽可能与训练集互斥，因为我们要测试的是泛化能力，就像考试出原题的话是测不出学生的“举一反三”能力的。 当只有一个包含 $m$ 个样例的数据集 $D = \\{(x_1,y_1),(x_2,y_2),…,(x_m,y_m)\\}$ 的时候，可以经过一些方法的适当处理来产生训练集$S$ 和测试集$T$: 留出法“留出法”（hold-out）是直接将数据集D划分成两个互斥的集合，其中一个集合作为训练集S，另一个作为测试集T，即：$S\\cupT=D,S\\capT=\\varnothing$。在S上训练出模型之后，用T来评估其测试误差，作为对泛化误差的估计。 比如一个二分类的任务，D有1000个样本，将其划分成S（700个）和T（300个），用S训练后，如果模型在T上有90个样本分类错误，那么其错误率为(90/300)*100% = 30%, 相应的精确度为 1-30%=70%。 updating","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://yanghaku.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://yanghaku.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"机器学习入门-西瓜书学习笔记（1）绪论","slug":"周志华机器学习笔记1绪论","date":"2020-02-03T05:19:00.000Z","updated":"2020-02-04T13:12:11.891Z","comments":true,"path":"2020/02/03/周志华机器学习笔记1绪论/","link":"","permalink":"https://yanghaku.github.io/2020/02/03/%E5%91%A8%E5%BF%97%E5%8D%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E7%BB%AA%E8%AE%BA/","excerpt":"作为一个对人工智能机器学习领域一无所知的小白，看到许多大神都在推荐周志华老师的《机器学习》这本书来入门。我也找到了这本书，想把这本书研究透彻，借助这本书迈进这个陌生的领域。正所谓不动笔墨不读书，我要在学习的同时，把读到的想到的学到的都记下来，才能更好地真正理解。希望能像前辈大神们那样，坚持读完这本书（并记下属于自己的西瓜书笔记）。就像书里说的那句这学期狠下功夫，基础概念弄得清清楚楚，算法作业也是信手拈来，这门课成绩一定差不了！加油!奥力给！ 基本概念","text":"作为一个对人工智能机器学习领域一无所知的小白，看到许多大神都在推荐周志华老师的《机器学习》这本书来入门。我也找到了这本书，想把这本书研究透彻，借助这本书迈进这个陌生的领域。正所谓不动笔墨不读书，我要在学习的同时，把读到的想到的学到的都记下来，才能更好地真正理解。希望能像前辈大神们那样，坚持读完这本书（并记下属于自己的西瓜书笔记）。就像书里说的那句这学期狠下功夫，基础概念弄得清清楚楚，算法作业也是信手拈来，这门课成绩一定差不了！加油!奥力给！ 基本概念 机器学习（machine learning）是致力于通过计算的手段，利用“经验”来改善系统自身的性能的一门学科。在计算机系统中，“经验”通常以“数据”的形式存在，所以机器学习研究的主要内容就是通过这些“数据”来产生模型的算法，也就是学习算法（learning algorithm）。也就是 原始数据（经验）\\xrightarrow{学习算法} 模型学习之后应用解决问题： 新的情况（经验没有的）\\xrightarrow{学习算法产生的模型} 对应的结果或判断这个模型泛指从数据中学到的结果。有的文献用模型来指全局性的结果（比如一棵决策树），用模式来指局部性的结果（比如一条规则）。 T.M.Mitchell在1997年所著的Machine Learning给出了更形式化的定义：假设用P来评估计算机程序在某任务类T上的性能，若一个程序通过利用经验E在T任务上获得了性能改善，则我们就说关于T和P，该程序对E进行了学习。 基本术语 数据集（data set）：进行机器学习需要的数据所有记录的集合。其中每一条记录是关于一个事件或者对象的一个描述，称为一个“示例”（instance）或“样本”（sample）。 属性 ： 反映事件或者对象在某方面的表现或性质的事项，称为“属性”（attribute）或“特征”（feature）。 属性值：属性上的取值称为“属性值”。 属性空间：属性张成的空间，称为“属性空间”（attribute space），“样本空间”或“输入空间”。 特征向量：由于空间中的每一个点对应一个坐标向量，因此我们也把一个样本称为特征向量（feature vector）。 维数：一个样本的特征的个数称为维数（dimensionality）。 比如一个西瓜（色泽=青绿,根蒂=蜷缩,敲声=浊响）这条记录就是示例或样本。所有的西瓜示例组成的集合就是数据集。“色泽”，“根蒂”，“敲声”就是属性。“青绿”，“蜷缩”，“浊响”就是对应的属性值。把西瓜的“色泽”，“根蒂”，“敲声”作为三个坐标轴，则他们张成一个用于描述西瓜的三维空间，每个西瓜都能在这个空间里找到属于自己的坐标位置。这个西瓜样本也叫做一个特征向量：(青绿,蜷缩,浊响)就是在样本空间对应的坐标。 在这里我的理解是数据集就像数据库里面的一张数据表，表里每一行记录是其中的一个样本，每一列就是对象的一个属性，对应的值也就是属性值。或者用面向对象的方法理解，把研究的对象的某些特征提取出来作为类的属性。每一个样本也就是一个类的实例，所有对象的集合就是数据集。 一般地，令$D = \\{ x_1,x_2,x_3,…,x_m \\} $ 表示包含 $m$个样本的数据集，每个示例由 $d$ 个属性描述， 则每个样本 $x_i = (x_{i1},x_{i2},x_{i3},…,x_{id})$ 是 $d$ 维样本空间 $\\chi$ 的一个向量($x_i \\in \\chi$), 其中 $x_{ij}$ 是 $x_i$ 在第 $j$ 个属性上的取值，样本$x_i$的维数为$d$。 学习/训练：从数据中通过某种学习算法学得模型的过程称为“学习”（learning）或者“训练”（training）。 训练过程中使用的数据称为“训练数据”（training data），其中每一个样本称为一个“训练样本”（training sample），训练样本组成的集合叫做“训练集”（training set）。 学习所得的模型对应了关于数据某种潜在的规律，因此亦成为“假设”；这种规律自身，则称为“真相”或“事实”（ground-truth）。学习的过程就是为了找出或逼近真相。 要学得一个能够“预测”（prediction）的模型，还需要获得训练样本的“结果”信息。 比如$(色泽=青绿,根蒂=蜷缩,敲声=浊响) \\Rightarrow 好瓜$ 标记：样本结果的信息称为“标记”（label），比如上面的“好瓜”就是标记。 样例：有了标记结果的样本，称为“样例”（example）。 标记空间：所有标记的集合，称为“标记空间”或“输出空间”。 一般地，用$(x_i,y_i)$ 表示第 $i$ 个样例，其中 $y_i \\in Y$是示例 $x_i$ 对应的标记，$Y$ 是标记空间。 如果预测的是离散值，则此类学习任务称为“分类”（classification）。如果预测的是连续值，则此类学习任务称为“回归”（regression）。 比如预测瓜是“好瓜”还是“坏瓜”这就是分类，预测瓜的成熟度为“0.90”，“0.95”这种就是“回归”。 对于只涉及两个类别的分类，称为“二分类”（binary classification）任务，通常一个类称为“正类”（positive class），另一个类称为“反类”（negative class）。对于涉及多个类别的分类，称为“多分类”（multi-class classification）任务。 一般地，预测任务是希望通过对训练集 $\\{ (x_1,y_1),(x_2,y_2),(x_3,y_3),…,(x_m,y_m)\\}$进行学习，建立一个从输入空间$\\chi$到输出空间$Y$的映射$f:\\chi\\rightarrow Y$.二分类的任务通常令$Y=\\{-1,+1\\}$ 或 $\\{0,1\\}$, 对于多分类的任务$|Y| \\gt 2$，对于回归任务，$Y = R$（即为实数集）。 学得模型之后，使用其进行预测的过程称为“测试”（testing），被预测的样本称为“测试样本”（testing sample）。测试样本的集合称为“测试集”（testing set）。 训练学得$f$之后，对测试样本$x$，就可以得到预测标记$y = f(x) $. 除了预测任务之外，我们还可以对训练集做“聚类”（clustering），即对训练集中的样本分为若干组，每一组称为一个“簇”（cluster）。这些自动形成的簇可能对应一些潜在的概念划分，有助于我们了解数据内在的规律，能为更深入地分析数据建立基础。 比如将西瓜分为“浅色瓜”，“深色瓜”或者“大瓜”，“小瓜”。 在聚类学习中，像例子上的“浅色瓜”这种概念是我们事先不知道的，而是通过学习得到了这些概念。而且学习过程中使用的训练样本通常都不拥有标记信息。 根据训练数据是否拥有标记信息，学习任务可以大致分为两大类：“监督学习” （supervised learning）和 “无监督学习” （unsupervised learning）。监督学习的代表就是分类和回归，无监督学习的代表就是聚类。 机器学习的目标是使得学得的模型很好地适用于“新样本”，而不是仅仅在训练样本里工作得很好。（预测任务对新样本预测的结果的也要很准确，聚类学习学得的簇划分在新样本上也要适用）。 学得模型适用于新样本的能力，称为“泛化”（generalization）能力。具有强泛化能力的模型能很好地适用于整个的样本空间。 训练集（特殊），训练之后适用于测试集（一般），也就是模型从特殊到一般的能力。 所以说，尽管训练集只是样本的很小的采样，我们仍希望它能很好地反映出样本空间的特性，否则就很难期望在训练集上学得的模型能在整个样本空间上都工作得很好。假设样本空间中全部服从一个未知的$D$分布，我们训练样本越多，那么得到的关于$D$的信息就越多，就越有可能通过学习获得具有强泛化能力的模型。 假设空间概念学习科学推理的两个基本手段：归纳与演绎。归纳是从特殊到一般的“泛化”过程，演绎是从一般到特殊的“特化”过程。“从样例中学习”显然是一个归纳的过程，因此亦成为“归纳学习”（inductive learning）。归纳学习有狭义和广义之分。广义的归纳学习就是从样例中学习，而狭义的归纳学习则要求从训练数据中学得概念（concept）（也称作“概念学习”或“概念形成”）。概念学习技术目前研究、应用都特别少，因为要学得泛化性能好且语义明确的概念实在太困难了，现实常用的技术大多都是产生一个黑箱模型而不是一个明确语义的概念（广义的归纳学习）。（当然，了解概念学习还是对机器学习的学习有帮助的） 概念学习中最基本的就是布尔概念学习，即对“是”，“不是”这样的可表示为0/1布尔值的目标概念的学习。比如我们得到了一个这样的数据集： 编号 色泽 根蒂 敲声 好瓜 1 青绿 蜷缩 浊响 是 2 乌黑 蜷缩 浊响 是 3 青绿 硬挺 清脆 否 4 乌黑 稍蜷 沉闷 否 这里要学习的目标就是“是不是好瓜”，假设由“色泽”，“根蒂”，“敲声”这三个因素完全确定，那么我们学习的目标就是“好瓜是色泽?、根蒂?、敲声?的瓜” 这样的概念。用布尔表达式表示是：“好瓜 $\\leftrightarrow$ (色泽=?) $\\land$ (根蒂=?) $\\land$ (敲声=?)”。我们的任务就是通过对这个训练集的学习，将前面的三个“？”确定下来。 注：如果只是将训练集里面的内容记住，以后再见到一模一样的瓜就能判断，但是对于没见过的瓜就没有了判断能力，这“记住样本”是所谓的“机械学习”或“死记硬背式学习”。这已经和我们的“泛化”的目的相背离了。这和我们人类的学习一样，死记硬背是学不到真正的东西，学不到解决问题的能力的，只有培养举一反三的能力，灵活运用才能是真正的学习。 假设空间学习的过程可以看作是枚举所有的假设的过程，搜索出那些能将训练集中的瓜判断正确的假设，也就是能和所有的训练集数据匹配的假设。所有的假设组成的空间称为假设空间。假设空间及其大小规模是由假设的表示决定的。比如西瓜的例子：“好瓜 $\\leftrightarrow$ (色泽=?) $\\land$ (根蒂=?) $\\land$ (敲声=?)”。如果色泽的取值有两种：“青绿”、“乌黑”，根蒂的取值有两种：“蜷缩”、“稍蜷”，敲声的取值有两种：“浊响”、“沉闷”。因为每一种属性有可能会取什么值都合适，我们用通配符“*”来表示这种取值。还有一种可能是无论这三种属性取什么值都没有“好瓜”存在，我们用“$\\varnothing$”表示这种假设。这样，假设空间的规模大小就是：$(2+1)*(2+1)*(2+1)+1 = 28$ 。 在西瓜的这个大小为28的假设空间里面，有1个是$\\varnothing$,另外27个则是{ “青绿”，“乌黑”，“*” }和 { “蜷缩”，“稍蜷”，“*” } 和 { “浊响”，“沉闷”，“*” } 的组合。 可以用很多策略对这个假设空间进行搜索，比如自顶向下，从特殊到一般，从一般到特殊等。搜索过程中可以不断删除与正例不一致的假设，最终会得到与训练集一致的所有假设，这就是我们学得的结果。在现实问题中，我们的假设空间规模通常非常大，但学习是基于有限的样本训练集进行的，因此可能会有多个假设与训练集一致。这些假设构成的集合称为“版本空间”（version space）。 比如说上面的西瓜问题，搜索后得到了3个满足的假设，也就是版本空间为：(色泽=*,根蒂=蜷缩,敲声=*)(色泽=*,根蒂=*,敲声=清脆)(色泽=*,根蒂=蜷缩,敲声=清脆) 归纳偏好上一节获得的版本空间会带来一个麻烦：有多个和训练集一致的假设，但他们面对新样本的时候却会产生不同的输出。然而，对于一个具体的机器学习的算法而言，它必须产生一个模型，也就是说必须从里面选择出一个。这时候，学习算法本身的“偏好”就起到了关键作用。 例如，若我们的算法喜欢“尽可能特殊”的模型，那么我们就会选择“好瓜$\\leftrightarrow$ (色泽=*,根蒂=蜷缩,敲声=清脆)”;若我们的算法喜欢“尽可能一般”的模型，并且由于某种原因更“相信”根蒂，那么它会选择“好瓜$\\leftrightarrow$ (色泽=*,根蒂=蜷缩,敲声=*)”。 机器学习在学习过程中对某种类型假设的偏好，称为“归纳偏好”（inductive bias），或者简称为“偏好”。 任何一个有效的机器学习算法必有其归纳偏好，否则它将会被假设空间中看似在训练集上“等效”的假设所迷惑，而无法产生确定的学习结果。 归纳偏好可以看作是学习算法自身在一个可能很庞大的假设空间中对假设进行选择的启发式或“价值观”。对于偏好的制定者来说，归纳偏好对应了学习算法中做出的“什么样的模型更好”的假设，这个假设是否成立，归纳偏好是否与问题本身匹配，大多数直接决定了算法是否取得好的性能。脱离具体的问题，空泛地谈论“什么学习算法更好”毫无意义，因为若考虑所有潜在的问题，则所有学习算法都一样好。要谈论算法的相对优劣，必须要针对具体的学习问题，在某些问题上表现好的学习算法，在另一些问题上却可能不尽如人意，学习算法自身的归纳偏好与问题是否相配，往往会起到决定性的作用。 EOF 西瓜书pdf下载链接 链接：https://pan.baidu.com/s/1-NKceuYl-3J-zxStrva6pQ提取码：hvis","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://yanghaku.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://yanghaku.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"Xamarin.Android 运行原理","slug":"Xamarin.Android运行原理","date":"2020-02-02T01:25:00.000Z","updated":"2020-02-02T07:17:10.255Z","comments":true,"path":"2020/02/02/Xamarin.Android运行原理/","link":"","permalink":"https://yanghaku.github.io/2020/02/02/Xamarin.Android%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/","excerpt":"这篇文章主要内容：Xamarin.Android应用的体系结构Xamarin.Android应用怎么运行在Android系统中的。MCW和ACWXamarin.Android应用包的结构 前置知识：Android操作系统的基础知识 概述在Android原生的开发中，主要运行的是Java或Kotlin编译后的字节码（.dex）每个应用单独分配一个ART虚拟机，运行在linux内核之上。 对于其他语言做的应用在Android平台运行，像c/c++这种静态编译的语言，可以直接编译成二进制码，通过JNI（java本地接口）与java通信（调用操作系统的API），直接运行在Library层即可（因为这一层是c/c++实现的，所以这一层也提供了原生c/c++的API供调用）。 而Xamarin是用C#开发的语言，C#和java一样，也是即时编译（JIT）语言，编译成中间语言（IL）之后需要在 .NET虚拟机上运行（在移动端是Mono虚拟机）。Android操作系统本身就没有C#的运行环境，而C#不能直接编译成二进制机器码，所以要融入Android，还需要在每个应用里带着 .NET运行时（Mono虚拟机）。这样C#才能在Android系统里运行。","text":"这篇文章主要内容：Xamarin.Android应用的体系结构Xamarin.Android应用怎么运行在Android系统中的。MCW和ACWXamarin.Android应用包的结构 前置知识：Android操作系统的基础知识 概述在Android原生的开发中，主要运行的是Java或Kotlin编译后的字节码（.dex）每个应用单独分配一个ART虚拟机，运行在linux内核之上。 对于其他语言做的应用在Android平台运行，像c/c++这种静态编译的语言，可以直接编译成二进制码，通过JNI（java本地接口）与java通信（调用操作系统的API），直接运行在Library层即可（因为这一层是c/c++实现的，所以这一层也提供了原生c/c++的API供调用）。 而Xamarin是用C#开发的语言，C#和java一样，也是即时编译（JIT）语言，编译成中间语言（IL）之后需要在 .NET虚拟机上运行（在移动端是Mono虚拟机）。Android操作系统本身就没有C#的运行环境，而C#不能直接编译成二进制机器码，所以要融入Android，还需要在每个应用里带着 .NET运行时（Mono虚拟机）。这样C#才能在Android系统里运行。 其实Android本身就是软件叠层的方式构建的操作系统，Android上没有支持C#运行的环境，应用安装的时候自己带上就好了。（就举个简单的栗子：windows本身不带着JRE，而用Java语言写的程序在windows上需要JRE来运行，那么我开发Java应用的时候直接在应用里打包一个给自己专门用的JRE，不就支持所有的Windows操作系统了~ ） 这只是简单来说，其实具体还得解决开发的时候操作系统的API调用等等各种问题。 体系结构先放一个官网文档里的架构图： 这张图是Xamarin.Android应用在Android平台上运行的架构图。右边的部分是原生的Android应用在Android系统上的架构图。左边是Xamarin.Android项目在对应层里面添加的运行依赖东西。首先就是在ART的同一层添加了Mono虚拟机（c语言实现的），运行在Linux之上。项目里面java编译的字节码通过ART执行，c#编译的字节码通过Mono虚拟机来执行。应用运行的时候，两个虚拟机在Linux内核之上并行运行的。 Xamarin.Android应用需要包装打包Mono虚拟机，所以产生的.apk文件比原生开发出来的要大。而且应用运行的时候，比原生应用多运行一个虚拟机，效率自然就低了不少。 两者通信：当Java代码运行的时候需要调用C#写好的代码的时候，就需要ART通过ACW来使Mono去运行。对于Xamarin.Android开发人员来说，C#的部分可以调用 .NET API（主要是C#语言的部分），也可以通过一些库来直接访问Linux操作系统的设备。但是Android操作系统大多数的访问（比如电话，音频等）都是java的API来访问的（右边的Java API Framework层），所以才有MCW来调用这些功能。简单来说，ACW是java代码运行的时候去调用C#代码的桥梁，而MCW是C#的代码去调用java代码的桥梁。 MCW 和 ACWMCW（Managed Callable Wrappers）：托管可调用包装器ACW（Android Callable Wrappers）：安卓可调用包装器 ACW: Android callable wrappers are a JNI bridge which are used any time the Android runtime needs to invoke managed code.ACW是一种JNI(java native interface)桥，这里的managed code指的是C#编译后的中间语言（IL）。ART运行的java代码通过ACW来调用C#代码在Mono中执行。 MCW：Managed Callable Wrappers are a JNI bridge which are used any time managed code needs to invoke Android code and provide support for overriding virtual methods and implementing Java interfaces。MCW也是一种JNI桥，为C#调用Android系统的API或者第三方写好的Java类库提供支持。 通过这两种方式，就可以让C#代码与Android平台的代码进行通信而且正常地运行了。 应用程序包Xamarin.Android开发出来的应用，结构上与普通的应用程序包差不多，比如res里的布局等，还多了以下的内容： 应用程序集（包含C#编译后的IL） Native libraries（对于不同架构机型的Mono运行时） 比如打包的HelloWorld.apk，解压后的目录：assemblies文件夹里就是应用程序集，包含了各种编译后的.dll文件lib文件夹里面就是native libraries。里面有个文件夹arm64-v8a和armeabi-v7a,里面都是分别对应处理器架构的Mono虚拟机（.so文件）。 其他的就跟普通的应用程序包差不多了，比如根目录的清单文件，res资源文件夹等。 总之一句话：The APK is still a valid Java APK. It Starts in ART,and uses ART for UI(Android.*classes). Mono is used to run .NET IL. The IL and Android native code run side-by-side and communicate via callable wrappers. (github的一条issue里面的，总结的很到位，我翻译不了只能放英文了)。 参考链接 官网文档 Xamarin.Android 运行原理 JNI原理 - 简书","categories":[{"name":".NET学习","slug":"NET学习","permalink":"https://yanghaku.github.io/categories/NET%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yanghaku.github.io/tags/Android/"},{"name":".NET","slug":"NET","permalink":"https://yanghaku.github.io/tags/NET/"},{"name":"Xamarin","slug":"Xamarin","permalink":"https://yanghaku.github.io/tags/Xamarin/"}]},{"title":"Android入门知识","slug":"Android入门知识","date":"2020-01-31T03:19:00.000Z","updated":"2020-02-01T07:33:43.067Z","comments":true,"path":"2020/01/31/Android入门知识/","link":"","permalink":"https://yanghaku.github.io/2020/01/31/Android%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/","excerpt":"想学习Android的第一步，就应该先了解这个平台系统的大体架构，应用的基础知识等，可是我看到很多入门教程第一步就是直接讲环境搭建下jdk什么的，这种太片面了，往后的NDK，安全沙盒什么的看了也很迷茫。所以我自己查找了许多资料并总结了一下。主要有：Android平台架构Android Application 基础知识 安全沙盒与最小权限原则 Android四大组件（重点） 组件启动与组件之间联系 应用的清单文件 应用资源Android SDK 目录结构及作用开发环境搭建","text":"想学习Android的第一步，就应该先了解这个平台系统的大体架构，应用的基础知识等，可是我看到很多入门教程第一步就是直接讲环境搭建下jdk什么的，这种太片面了，往后的NDK，安全沙盒什么的看了也很迷茫。所以我自己查找了许多资料并总结了一下。主要有：Android平台架构Android Application 基础知识 安全沙盒与最小权限原则 Android四大组件（重点） 组件启动与组件之间联系 应用的清单文件 应用资源Android SDK 目录结构及作用开发环境搭建 Android平台架构Android 是一个基于linux内核的开源软件栈，通过软件叠层的方式构建出来的一个操作系统。 平台的架构图（来自官网）： 从下到上分为五层： Linux内核层，HAL硬件抽象层，Library层，Framework层，Application应用层。 Linux内核层Android平台的基础是Linux内核，主要用linux内核执行一些底层的功能，比如线程和底层的内存管理，还有各种设备的驱动，直接和硬件打交道。linux内核的安全性也能保证这Android的安全。 HAL硬件抽象层HAL提供了一个标准的界面，向更高级别的javaAPI框架显示设备的硬件功能。每一个硬件组件都是对应着一个库模块，比如相机模块，蓝牙模块，音频模块等。当javaAPI框架需要访问硬件的时候，Android会为这些硬件加载对应的库模块。其实就是对底层硬件驱动的一种封装，让javaAPI框架层只看到一个标准的接口，而有了硬件的无关性。 Libarary层系统的运行库层，这层主要提供了一些必不可少的运行库。 Android RuntimeAndroid Runtime 包括两部分，一部分是核心运行时库，为javaAPI框架提供java语言中的大部分功能；另一部分是Android运行时。 在Android 5.0 之前，Android运行时都是Dalvik虚拟机。Dalvik虚拟机相当于一个适配于移动设备更优化的一个java虚拟机（JVM）,也是用JIT编译器来解释运行字节码。Dalvik运行的是.dex格式的字节码，是构建的时候将.java源码编译成 .class字节码，然后再压缩优化成.dex的字节码。 这个Dalvik可以与java虚拟机对比理解首先就是Dalvik本身就是一个魔改的java虚拟机，是一种基于寄存器的架构，虽然牺牲了一些平台无关性，但是在代码运行效率方面都比jvm更胜一筹。JVM与Dalvik区别： 运行的字节码不同，指令集架构不同，JVM基于栈，Dalvik基于寄存器 JVM只运行一个实例，所有的应用都运行在同一个虚拟机中，而Dalvik是每一个应用启动都有一个单独的Dalvik虚拟机对应，每一个Dalvik都对应linux里的一个进程。这样就算其中一个应用crash掉了，也不会影响其他的应用。 到了Android 5.0版本之后，这一部分就变成了Android Runtime（ART），ART与Dalvik相比，增加了更多的功能： 不仅有JIT，而且还增加了AOT（预先编译） 优化垃圾回收 更好的调试支持 预先编译是在安装的时候将 .dex 文件编译成机器码（所以安装的时间会变慢很多），运行的时候跳过了解释的阶段，运行效率之类的都显著提高，但是占用的存储空间就大了，也就相当于用空间来换时间。这样使CPU的利用率也降低不少，能够提升电池的续航时间。 总之，Android Runtime安卓运行时就是用来运行apk里的.dex代码的。一个APP对应一个ART实例，并且对应于一个进程。 Native C/C++ Libarary原生C/C++库，通过一些c/c++库为安卓系统提供了一些主要的特性支持。比如OpenGL库提供3D绘图，SQLite库提供数据库支持，WebKit库提供浏览器内核支持…. 这些主要是一些关键的东西（效率至上），所以是用C/C++的库来提供支持。 应用不仅可以调用javaAPI层来访问这里面的模块，而且可以直接调用这些原生库的功能（一般都是在c/c++原生开发的时候）。 NDK: native develop kit 原生开发工具包当c/c++ 原生开发的时候用到的工具包，其实对大部分的应用都没有很大的价值，因为这不可避免地增加了开发的复杂度。一般在以下场景才会用到： 为了非常好的性能。例如游戏，物理模拟这些计算密集型的应用 重复使用自己或者其他开发者已经开发好的c/c++库 在平台之间移植应用 JAVA API Frameworkjava API框架，这层主要是用java写的API，包含了Android OS的整个功能集（也就是说开发的时候可以调用这里面的API就可以实现所有功能）。里面包括着各种系统的服务和四大组件（后面会介绍到）。 System Application 和 Application系统应用可以说是系统内置的应用，这些对于开发者而言，可以像调用java API Framework一样来调用这些System Application。Application就是我们自己写的第三方的应用这种了，是在最上层。 总之，Android APP的开发语言最好还是官方的JAVA/Kotlin，如果有特殊的需要才会用到native c/c++.对于应用开发人员主要研究的就是架构里面的Java API Framework层和System Application层。如果有需要还会用到native c/c++ Library。就像Android运行时和运行库和下层的驱动等，不是研究的重点，在把握全局的同时，也要搞清楚重点。 Android Application 基础知识一个APK文件，包含一个Android应用的所有内容。使用Kotlin，Java，c++编写Android应用，Android SDK会将代码连同数据和资源文件编译成一个APK（Android Package），即带有.apk后缀的归档文件。 安全沙盒与最小权限原则安全沙盒 security sandbox 沙箱(盒)是为执行中的程序提供隔离环境的一种安全机制。它通过严格控制执行的程序锁访问的资源，以确保系统的安全。每一个Android应用都处于各自的安全沙盒里面，它们直接不能互相访问文件等。 Android操作系统首先是多用户的Linux系统，对于每一个应用都是一个不同的用户。 默认情况下，系统会为每一个应用分配一个唯一的用户ID，系统为应用中的所有文件设置权限，使得有权限的用户才能访问对应的文件。 每个进程都拥有一个独立的虚拟机，默认情况下，每个应用都在其自己对应的Linux进程上执行（应用-虚拟机-Linux进程 这三个是一对一的关系） 最小权限原则对于每一个应用，也就是对应的一个唯一的Linux用户，默认情况下只能访问其工作所需要的组件。在此环境中，应用无法访问其未获得权限的系统部分。应用要想访问其他应用的共享数据或者系统服务，有两个途径： 让两个应用共享一个Linux用户（也就是说两个应用的linux userid相同），这样二者可以互相访问。在节省资源的时候，也可以安排拥有相同用户ID的应用在同一个Linux进程内运行，共享同一个虚拟机。 应用可以请求访问设备数据的权限，由用户明确授予这些权限。比如说应用请求获得访问文件，访问相机，访问联系人等等的权限，由用户明确授予即可。 Android四大组件（重点）应用的四大组件： Activity： 拥有用户界面的单一屏幕 Service：在后台运行的组件，没有界面 BroadcastReceiver： （广播接收器）相应系统的广播通知的组件 Content providers：（内容提供程序），管理共享数据，为其他应用提供查询修改接口 ActivityActivity是与用户交互的入口点，拥有单个的屏幕。 官网上的举例：例如电子邮件的应用可能会有三个Activity： 显示新电子邮件列表的Activity 用于撰写电子邮件的Activity 用于阅读电子邮件的Activity这三个紧密协作联系，但是每个Activity都是独立于其他的Activity而存在，其他应用可以启动其中任何一个Activity。 这很像一个web中的一个网页，每一个网页都是独立的，它们一起构成一个网站，其他别的链接也可以打开这个网站里的任何一个网页（当然在Android里面就还会涉及到权限能不能打开的问题）。然后同一时间只能有一个网页显示在屏幕上（独占一个屏幕）。 Activity的生命周期首先是一个标准的图： Activity 包括7个生命周期的流程，分别是： 1onCreate(),onStart(),onResume(),onPause(),onStop(),onDestory(),onRestart(). 其中 onCreate()是生命周期的开始，onDestory()是生命周期的结束 Activity启动： onCreate() -&gt; onStart()（此时不可见） -&gt; onResume -&gt; 处于运行态，可见 Activity被暂时覆盖：onPause() , 当用户取消覆盖的时候 onResume() 恢复 Activity跳转到了新的Activity、Activity进入了后台或者锁屏的时候：running的Activity -&gt; onPause() -&gt; onStop() -&gt; 停滞状态的Activity Activity重新回到前台或者解锁的时候： 停滞状态的Activity -&gt; onRestart() -&gt; onStart() -&gt; onResume() -&gt; Activity重新running Activity在后台且内存不足的时候：系统会杀死这个后台状态的Activity（此时这个Activity的引用虽然在任务栈中，但是这个时候引用指向的对象已经是null）。若想再回到running，就需要重新初始化生命周期: onCreate() -&gt; onStart() -&gt; onResume() Activity退出: onPause() -&gt; onStop() -&gt; onDestory() (上面的方法都是对应事件的回调函数，选择重写的方法而不能主动调用。如果想主动退出Activity，应该调用finish())。 Activity的四种启动模式因为我们的APP一般都是由多个Activity构成的，而在Android给我们提供了任务（Task）的概念，就是将多个相关的Activity收集起来，进行Activity的跳转与返回。实现Android就是通过任务栈来管理这些Activity的。任务栈：任务栈是一种后进先出的结构。切换到新的Activity，就会被压入栈中成为栈顶。位于栈顶的Activity处于running状态。当back按钮按下的时候，栈顶的Activity会出栈并且调用onDestory()结束生命周期，紧随其后Activity的成为栈顶。当栈内没有Activity那么系统就会回收这个栈，每个APP默认只有一个栈，以这个APP的包名来命名。 四种启动模式： standard标准模式: 默认的模式，新的Activity会默认压入栈中。 singleTop栈顶复用模式：如果新的Activity在任务栈的栈顶（也就是跟栈顶的相同）那么就不会重新创建。如果不在任务栈的栈顶，就跟standard模式相同。 singleTask栈内复用模式：如果新的Activity在任务栈的栈内，那么新的Activity就不会创建，而是将原本栈内的Activity调到栈顶（这个Activity之上的所以Activity都会被清理销毁）。 singleInstance单例模式：这个要求更严格，这种模式的Activity只能单独的位于一个任务栈里面，是一个加强版的singleTask。任务栈里面只能有这一个Activity。 Service服务是Android中实现程序后台运行的解决方案，非常适合去执行那些不需要和用户交互而且还要求长时间运行的任务（没有界面）。比如下载，播放音乐等等。 Service的生命周期先看图：首先service的声明中，onCreate()只会回调一次来创建,onDestory()只会在关闭的方法回调一次。启动service的方法有三种： StartService()启动service BindService() 启动service start之后再bind 这几者的区别：StartService只是启动这个service，启动它的组件（比如Activity）和这个Service没有关联。service的关闭只能是自己执行完某些任务了之后执行stopSelf或者其他组件调用它的stopService才能终止。BindService方法启动的Service，其他组件可以通过回调获取Service的代理对象和Service交互，而且两方进行绑定，当启动的组件销毁的时候，Service会自动进行unBind操作解绑。当发现所有的绑定都进行了unBind的时候，Service会销毁。先start然后另一个组件进行bind这个已经启动的Service的时候，系统仅仅是进行了绑定而不会把生命周期与另一个组件绑定。也就是解绑了之后Service还是属于start启动的service。 BroadcastReceiver广播能够广泛的运用在应用程序之间传递事件信息的机制。借助广播接收器，系统能够在常规的用户流之外向应用传递事件，从而允许应用响应系统范围内的广播通知。广播接收器可以对许多外部事件进行响应，比如当电话呼入，手机屏幕关闭等事件，系统会发出广播，对应的注册的广播接收器会收到这些事件消息对应地处理。广播接收器虽然没有界面，但是可以创造状态栏的通知。比如wifi连接-&gt; 系统广播事件-&gt;对应的广播接收器收到后创建通知：网络连接恢复。 广播接收器有两种注册方法：静态注册和动态注册 静态注册： 在AndroidManifest.xml（应用清单文件，下文会仔细解释）里声明，当APP首次启动的时候就注册到系统中。 动态注册： 在某个组件（一般是Activity）运行的时候注册广播接收器。区别：静态注册是一直在监听对应的消息，耗电耗内存，当APP退出之后也能收到对应的消息进行处理。 动态注册是在代码中动态的注册，当组件退出之后也没法接受广播了（注意要在组件结束前移除广播接收器，否则会导致内存泄漏）。 Content providers内容提供者提供内容的共享。可以将文件，数据库，网络上的可持久化的数据提供给其他应用修改查询。一般有两个场景： 自己的应用需要访问别的应用的数据，比如访问手机联系人，短信等，想对这些数据进行读取或修改，就要用到这些应用的ContentProvider。 自己的应用需要给别的应用共享信息，也要用到ContentProvider，而且可以选择性的共享信息，避免了关键隐私信息泄露等。 组件启动与组件之间联系Android系统的独特之处在于，任何应用都可以启动其他应用的组件。 比如一个应用想让用户使用设备相机拍摄照片，那可以使用系统的照片应用中对应的Activity即可，当拍摄之后会返回到原先的应用，对用户来说这相机就如同应用的一部分。当系统启动一个应用的组件时候，就会启动这个应用对应的进程（如果没有启动的话）。这个应用和相机还是属于两个进程。所以说Android应用没有单个的入口点（main()函数），每一个组件都可以是应用的入口。 因为安全沙箱的存在，不能直接启动另一个应用的组件，而是需要系统作为中间人。这些组件之间启动或者访问，就需要传递消息，这个消息就是 Intent（意图）。 Intent 是启动组件，是组件直接联系的桥梁。四种组件之中，Activity，Service，BroadCastReceiver 这三个组件都是通过Intent启动。（ContentProvider会在ContentResolver请求目标的时候启动，与其他不一样）。对于启动Activity和Service，Intent会定义要执行的操作，并且可以指定待操作的数据等信息。对于BroadcastReceiver，Intent只会定义待广播的通知。 Intent对象大致包括7个属性：Action（动作），Data（数据），Category（类别），Type（数据类型），Component（组件），Extra（扩展信息），Flag（标志位）。 Intent分为显式Intent和隐式Intent。 显式Intent： 直接通过组件名来启动某个组件，每次启动的组件只有一个。 隐式Intent： 不指定组件名，而是指定Intent的Action，Data等（只描述意图），当我们启动的时候，会匹配出相关的满足要求的组件，如果不止一个，就会让用户选择使用哪个来处理Intent。一个最熟悉的场景就是隐式Intent： 应用的清单文件在Android系统启动应用之前，系统必须通过读取应用的清单文件（AndroidMainifest.xml）确认组件的存在，应用中所有用到的组件(除了动态注册的广播接收器) 都需要在这个文件中声明。这个文件必须位于应用目录的根目录中。除了声明应用的组件之外，清单文件还有许多其他的作用，比如： 确定应用需要的任何用户权限，比如访问联系人，访问文件等 根据应用使用的API，声明所需的最低API级别 声明需要的硬件软件功能，比如相机等 主要的三个功能： 声明组件代码里的Activity就是声明的一个组件 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest ... &gt; &lt;application android:icon=\"@drawable/app_icon.png\" ... &gt; &lt;activity android:name=\"com.example.project.ExampleActivity\" android:label=\"@string/example_label\" ... &gt; &lt;/activity&gt; ... &lt;/application&gt;&lt;/manifest&gt; 声明组件的功能这个就是声明了一个执行动作为SEND发送的一个组件 123456789101112&lt;manifest ... &gt; ... &lt;application ... &gt; &lt;activity android:name=\"com.example.project.ComposeEmailActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.SEND\" /&gt; &lt;data android:type=\"*/*\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 声明应用要求 123456&lt;manifest ... &gt; &lt;uses-feature android:name=\"android.hardware.camera.any\" android:required=\"true\" /&gt; &lt;uses-sdk android:minSdkVersion=\"7\" android:targetSdkVersion=\"19\" /&gt; ...&lt;/manifest&gt; 应用资源Android应用不仅仅是代码，还需要与源代码分离的静态资源，比如图像，音频文件还有xml文件定义的界面动画等。所有的资源都在 /res 的文件夹内。 Android SDK 目录结构及作用1234567891011121314android-sdk&#x2F; add-ones&#x2F; -&gt; 一些附加的库，第三方公司的附加功能，比如GoogleMaps等 build-tools&#x2F; -&gt; 构建项目的时候用到的工具，还包括一些编译工具等 28.0.3&#x2F; 29.0.3&#x2F; docs&#x2F; -&gt; 离线的开发者文档（可选） platforms&#x2F; -&gt; sdk里面最重要的文件，每个文件夹都含有各个版本的sdk android-28&#x2F; -&gt; API级别28的sdk版本 android-29&#x2F; platforms-tool&#x2F; -&gt; 各版本sdk通用的工具，比如abd.exe,sqlite3.exe等 skins&#x2F; -&gt; 安卓模拟器的皮肤 system-images&#x2F; -&gt; 创建安卓模拟器的时候使用的系统镜像 android-28&#x2F; tools&#x2F; -&gt; 通用的Android开发、调试的工具 还有两个很重要的工具： SDK管理器 和 安卓模拟器管理器。（可以直接用IDE上带的工具来代替） 开发环境搭建操作系统：win10IDE：Android Studio （用起来跟idea一个感觉，非常棒！比VS强太多了）（直接官网下载安装即可） 安装之后主要是设置SDK和模拟器。（我之前用VS下过一个sdk，Android Studio直接识别出来本地的了！） 设置好之后就新建工程，然后新建一个空白的工程，一路next，IDE会自动生成一个空白项目。项目结构如下： 根目录里的清单文件 AndroidMainifest.xmljava/ 下的java代码（只有一个组件MainActivity）res/ 里是应用的各种资源，包括布局，图片等等。res/layout 里的activity_main.xml 就是MainActivity这个Activity对应的布局文件。 配置好模拟器设备之后，直接点击run运行即可完成 Hello World! 参考链接 Android开发者平台（官网有最新文档） Android基础入门教程-菜鸟教程 简单理解Android Dalvik Android Runtime (ART) 和 Dalvik NDK开发从放弃到入门 安卓基础知识-简书 安卓四大组件-简书 Android四大组件：BroadcastReceiver史上最全面解析-简书","categories":[{"name":"Android学习","slug":"Android学习","permalink":"https://yanghaku.github.io/categories/Android%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yanghaku.github.io/tags/Android/"}]},{"title":"Xamarin学习1 -- 概念篇","slug":"Xamarin学习1概念篇","date":"2020-01-30T08:46:00.000Z","updated":"2020-02-01T08:32:05.914Z","comments":true,"path":"2020/01/30/Xamarin学习1概念篇/","link":"","permalink":"https://yanghaku.github.io/2020/01/30/Xamarin%E5%AD%A6%E4%B9%A01%E6%A6%82%E5%BF%B5%E7%AF%87/","excerpt":"主要介绍了 Xamarin 中 Xamarin.forms , Xamarin.Android, Xamarin.iOS 的区别和联系，并且搭建环境和创建第一个 Xamarin.forms 应用并运行调试。","text":"主要介绍了 Xamarin 中 Xamarin.forms , Xamarin.Android, Xamarin.iOS 的区别和联系，并且搭建环境和创建第一个 Xamarin.forms 应用并运行调试。 XamarinXamarin是Mono开源项目的一个分支，把Mono里移动开发这一块专门拿出来做成了一个商业项目。（原先是收费的商业项目，到了2016年微软把Xamarin公司收购了，才变成开源的了。）现在Xamarin是一个开源平台，用于通过 .NET 构建适用于 IOS，Android 和 Windows 的新式应用程序。是一个抽象层，可用于管理共享代码与基础平台代码的通信。使开发人员能够跨平台共享应用程序，允许开发人员以一种语言编写所有的业务逻辑，但是在每个平台上各自实现外观等。 说白了就是共享底层逻辑的 C# 的代码，并且创建各自的UI, 使得一个工程开发能够多个平台使用。 然后就是 Xamarin 的结构： Xamarin.AndroidXamarin.Android 是将 C# 编译为中间语言，然后在程序运行的时候，通过即时编译（JIT）编译成本机程序集（类似于java虚拟机的那种）。 Xamarin.iOSXamarin.iOS 是将应用程序完全编译成本机的ARM程序集代码（完全的静态编译）。 Xamarin.Android 和 Xamarin.iOS 其实就是两个单独的工程，前者是专门对于Android开发的，后者是专门对于iOS开发的工程。但是Xamarin不是跨平台的吗？ 这个时候就用到了 Xamarin.Forms 了！ Xamarin.FormsXamarin.Forms 是一个开源的 UI 框架，允许开发者写一种UI布局与设计，然后根据不同的平台渲染成不同的UI控件(实现了跨平台的UI开发) 上图中的 Xamarin.Forms Platform Renderer 就是做这种事情的。 就像官网文档说的： Who Xamarin.Forms is forXamarin.Forms is for developers with the following goals: Share UI layout and design across platforms. Share code, test and business logic across platforms. Write cross-platform apps in C# with Visual Studio. UI的开发可以是原生开发，也可以是用Xamarin.Forms开发，原生开发就是使用Android和iOS原生的UI控件。基于Xamarin.Forms的UI开发可以使代码共享程度进一步提高：从上图可以看到，左边的原生UI开发，代码共享程度是75%左右，也就是说只是共享了后台的逻辑代码了，前端的UI还是要各自做各自的。右边的Xamarin.Forms开发的项目，代码共享程度到了95%，这就几乎没有多少平台相关的代码了。 以上的关系总结 Xamarin.Android 和 Xamarin.iOS (其实还有Xamarin.Mac , Xamarin.UWP，Xamarin.tvOS 等) 这些都是Xamarin里的具体的工程， 专门对应于具体的平台里的，可以单独开发。 而Xamarin.Forms 是用于跨平台的，可以实现同时开发Android和iOS和UWP 等，将一个共享的UI框架分别渲染到具体的平台工程里去，实现大部分的UI和逻辑代码共享。 比如在VS2019 里面创建一个Xamarin项目的时候，可以看到非常多的选项： 第一个Xamarin.Forms 就是一个跨平台的方案，当在Xamarin forms创建的时候勾选这Android和iOS的时候(因为没有装UWP的开发环境，所以只选了这两个)，项目的结构就会如下： 也就是说， Xamarin.Forms 包含了其他的工程，而像 Xamarin.Android 这种既可以是独立开发的工程，也可以当做Xamarin.Forms 里的一部分通过Xamarin.Forms 一起开发。 所以说清楚了这些之后，官网上的那些文档也就不觉得混乱了， 想学哪一块就可以针对性地学习了。 环境搭建操作系统 ： win10 IDE： visual Studio 2019 （刚下载的） 如果只需要Android和iOS开发的话，只要在vs installer 上选择移动开发的负载下载即可 安卓需要java SDK 8， Android SDK 和安卓模拟器 这三个东西vs都给自动装好了. 其中jdk8自动被安装才了“C:\\Program Files\\Android\\jdk\\microsoft_dist_openjdk_1.8.0.25”. Android SDK 装在了 “C:\\Program Files (x86)\\Android\\android-sdk” （当然，可以自己设置） 然后安卓的模拟器就是自动保存在了自己用户文件夹下的 “.Android” 里面（这个需要自己安装设备，具体在下文） 安卓模拟器有硬件加速，运行之前需要在 “控制面板”-&gt; “程序与功能” -&gt; 左栏 “启用或关闭windows功能” -&gt; “windows虚拟机程序监控平台” 勾选上， 否则每次运行之前都会有一个警告。 第一个 Xamarin.Forms 工程打开vs， 新建项目，在框里搜索 Xamarin， 点击选中 Xamarin.forms, 然后设置项目名称，目录等， 然后点创建。 之后选择空白的模版， 平台勾选Android和iOS （有环境的也可以勾选UWP试试），然后就创建完成。 项目结构： 其中XamarinApp1.Android 就是对应的生成安卓的工程， XamarinApp1.iOS 就是对应的iOS的工程。 在MainPage.xaml 中编辑，把 “Welcome …” 换成 “hello World” （程序猿开发第一步嘛），然后就是运行了。 Xamarin.Android 的运行调试运行安卓之前需要安装安卓的模拟器，VS的安卓工具里有两个挺重要的工具：Android SDK管理器和 Android 设备管理器。 点击工具 -&gt; Android -&gt; Android SDK 管理器 我这上面是下载的默认的 安卓SDK9; 设置的图片： Android SDK 有了之后，就安装对应的设备就行了。点击 工具 -&gt; Android -&gt; Android Device Manager 点击新建（新建一个安卓虚拟设备） 操作系统要选择已经装好的sdk对应的版本， 处理器选择 x86（官网说x86比x86_64实际会快，而且可以硬件加速） ，其他可以不用多设置（以后可以再改嘛，先能运行再说）， 点击创建即可。 创建完成后，在上面的工具栏里，选择需要运行的Android和对应的设备，点击运行，即可完成 运行截图： 到此第一步完成，Android上部署成功！ Xamarin.iOS 运行调试Xamarin.iOS 调试需要iOS真机， 如果是模拟器也需要MAC系统才行（贫穷限制了开发人员的学习）。 找了一圈，发现了一个方案： windows装 MAC虚拟机，然后再MAC上装模拟器和VS，详情 可以实现但是太麻烦，就不瞎折腾了。 这个跨平台是挺棒，但是不代表着学习了Xamarin就会了Android和iOS的开发， 每个平台的特性都需要了解的。iOS 系统的很多特性都不了解是写不出来高质量的程序的，甚至还得要求开发者掌握一些 Object-C 的语法 。所以说没有接触使用过iOS的我果断放弃啦.. 所以对于我个人来说，往后的学习可能只是限制在Xamarin.Android， 而不是上面的跨平台特性（没有其他平台的需求）。 如果只学习 Android开发，用java入门更好，但是多学点新的东西不也很刺激么hh 以上仅仅是我个人的理解，不一定是完全正确的！！ 如果有错误请评论指出，谢谢！ 参考链接 官网Xamarin文档 Xamarin.Form与Xamarin.Android或Xamarin.IOS的区别简述 写给 iOS 程序员的 Xamarin 入门教程 Xamarin介绍","categories":[{"name":".NET学习","slug":"NET学习","permalink":"https://yanghaku.github.io/categories/NET%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yanghaku.github.io/tags/Android/"},{"name":".NET","slug":"NET","permalink":"https://yanghaku.github.io/tags/NET/"},{"name":"Xamarin","slug":"Xamarin","permalink":"https://yanghaku.github.io/tags/Xamarin/"},{"name":"iOS","slug":"iOS","permalink":"https://yanghaku.github.io/tags/iOS/"}]},{"title":".NET初学概览","slug":"NET概览","date":"2020-01-29T08:46:00.000Z","updated":"2020-01-31T03:26:46.239Z","comments":true,"path":"2020/01/29/NET概览/","link":"","permalink":"https://yanghaku.github.io/2020/01/29/NET%E6%A6%82%E8%A7%88/","excerpt":"主要是对 .NET Core, .NET Standard, .NET framework 和 Xamarin 的介绍和区分 并且介绍一下其中的ASP.NET, UWP， XAMARIN 等 然后就是 .NET 的未来： .NET 5 （2019年5月宣布的下一代的版本），将把前面这些运行时全部合为一体 以前刚开始听说 .NET 的时候，我只知道 .NET framework , 然后昨天看了一眼官网的 .NET 入门学习的时候吗，又看到了 .NET Core, 然后各种名词接踵而来，有点懵，所以就总结了一下下。","text":"主要是对 .NET Core, .NET Standard, .NET framework 和 Xamarin 的介绍和区分 并且介绍一下其中的ASP.NET, UWP， XAMARIN 等 然后就是 .NET 的未来： .NET 5 （2019年5月宣布的下一代的版本），将把前面这些运行时全部合为一体 以前刚开始听说 .NET 的时候，我只知道 .NET framework , 然后昨天看了一眼官网的 .NET 入门学习的时候吗，又看到了 .NET Core, 然后各种名词接踵而来，有点懵，所以就总结了一下下。 首先就是当下的框架图： .NET广义的 .NET 是一个通用的开发平台，能够跨语言，跨平台 ，能够支持跨多个平台的方案 .NET 开发可以实现包括 .NET Framework、.NET Core 和 Mono。 .NET 的所有实现都有一个名为 .NET Standard 的通用 API 规范。 .NET 与 java 对比理解： .NET 与 java有很多相似的地方，两者都是即时编译语言（JIT）， 项目编译生成的文件不是具体的机器码，而是中间语言。 在java里面叫做字节码（bytecode）， 而在 .NET里面叫做中间语言（Common Intermediate Language，简称 IL），java官方运行环境是java的虚拟机JRE（Java Runtime Environment）， 而在 .NET 官方运行环境叫做公共语言运行时（Common Language Runtime， 简称CLR） 这是 .NET 跨语言，跨平台的基础 跨语言： c#， f#， VB.NET 这些面向 .NET 的都可以 跨平台： 开发 Windows，Linux，macOS，iOS，Android，tvOS，watchOS 和 WebAssembly .NET framework传统的 .NET framework 是以一种采用CLR 为基础，支持多种语言（c#，f#，VB.NET, c++，Python等）的开发。 这也是我们用到的最多最熟悉的 .NET , 这个缺点就是不能跨平台，只能在windows上用。一般就是用来做桌面应用程序和ASP.NET的. .NET Core主要是针对windows，linux，macOS，服务器和控制台应用程序的跨平台 .NET 实现 它支持四种应用程序：控制台，ASP.NET Core, 云 和通用windows平台( UWP ) 需要注意的是: 尽管微软把 .NET Core作为.NET未来的发展方向，但 .NET Core和 .NET Framework 仍然是两个独立的产品。.NET Framework也会继续更新和维护。 .NET Core 不再是windows 专门的，在其他平台也可以用。 就是为了跨平台而做的，不是windows的一个组件了。 .NET Standard.NET Standard 是一组由.NET 实现的基本的API集。 是一个进一步实现跨平台跨设备的代码共享。其实是未来 .NET的核心，一切基于它来实现代码共享。 .NET Standard 和 .NET 之间 相当于html 规范和 浏览器之间的关系，后者是前者的实现。 Xamarin 与 MonoMono是 .NET 开源之前的一个跨平台的方案，是由Xamarin公司主持的开源项目，可以运行于Linux等其他平台 （于2016年被微软收购）。相当于实现了各个平台上的 .NET 的公共语言运行时（CLR）。 现在主要运用在移动设备，许多著名的游戏引擎比如Unity3D也包含着这个技术。 对于IOS和Android 应用程序，Xamarin 将 .NET 技术代入里面， 成为唯一一个能够提供跨iOS，Android和windowsPhone 的单一语言平台。 ASP.NET 和 ASP.NET Core这两个只是以上框架里的一个小组件，用于开发Web应用程序。 然后两个的区别就是ASP.NET 是 .NET framework 里的组件， 只有windows版本的API 而ASP.NET Core 是 .NET Core 的组件，是对于跨平台准备的，是 ASP.NET 的跨平台版本。 所以说以上这么多的名词，都是因为不断进化产生的，从只有一个 .NET framework 只支持windows平台，到后来的跨平台的方案，都在慢慢发展来的。 三个框架与应用总结所以再回顾一下上面的那个图片: 现在主要的三个框架实现 .NET Framework （最新到4.8版本）主要是对windows平台的 .NET Core （最新到3.1版本）可以跨平台，主要是一些控制台设备，如linux，windows，macOS等 XAMARIN 主要是针对移动设备的，比如Android，iOS等 官网文档上说的： There are various implementations of .NET. Each implementation allows .NET code to execute in different places—Linux, macOS, Windows, iOS, Android, and many more. .NET Framework is the original implementation of .NET. It supports running websites, services, desktop apps, and more on Windows. .NET Core is a cross-platform implementation for running websites, services, and console apps on Windows, Linux, and macOS. .NET Core is open source on GitHub. Xamarin/Mono is a .NET implementation for running apps on all the major mobile operating systems, including iOS and Android. .NET Standard is a formal specification of the APIs that are common across .NET implementations. This allows the same code and libraries to run on different implementations. .NET 5 未来的展望现在这么多的框架什么的，到了 .NET5 将会融为一体。 .NET 5 将会融合 .NET Framework , .NET Core, Mono, Xamarin 等优点构建出一个统一的 .NET 平台，开发人员可以使用 C#， VB.NET, F# 等语言，使用相同的API 开发针对任何系统，任何架构，任何形态的应用程序，并且代码和库均可通过 .NET Standard 共享 。 也就是说，到了那个时候开发出一个应用程序，就可以全平台通吃，只要有一个 .NET, 就能一次开发出适用于Windows，Linux，macOS，iOS，Android，tvOS，watchOS 和 WebAssembly 等所有平台的应用程序了。 希望早日到来，让俺们这些开发人员感受感受叭。 2019年5月微软宣布的.NET5， 将会在 2020年11月发布 参考链接： .NET:持续进化的统一开发平台 .NET Core和.NET Standard有什么不同 (翻译)正式宣布 .NET 5","categories":[{"name":".NET学习","slug":"NET学习","permalink":"https://yanghaku.github.io/categories/NET%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":".NET","slug":"NET","permalink":"https://yanghaku.github.io/tags/NET/"},{"name":".NET Core","slug":"NET-Core","permalink":"https://yanghaku.github.io/tags/NET-Core/"},{"name":"Xamarin","slug":"Xamarin","permalink":"https://yanghaku.github.io/tags/Xamarin/"}]},{"title":"失踪半年人口回归","slug":"失踪半年人口回归","date":"2020-01-29T03:00:00.000Z","updated":"2020-01-29T13:29:00.195Z","comments":true,"path":"2020/01/29/失踪半年人口回归/","link":"","permalink":"https://yanghaku.github.io/2020/01/29/%E5%A4%B1%E8%B8%AA%E5%8D%8A%E5%B9%B4%E4%BA%BA%E5%8F%A3%E5%9B%9E%E5%BD%92/","excerpt":"今天是大年初五，2010.1.29， 在家连续玩了四天了，要开始继续学习了呀。 自从电脑从linux 换成 windows ，就没有再重新配置hexo的环境（说白了太懒了），昨天折腾了一整天，把电脑里的文件整理、清理，升级或者卸载不用的软件，外加更新几个linux的虚拟机，整整折腾了一整天。昨天又下了nodejs，重新搞了一下hexo，继续写吧，每天学学学，总得留下什么吧。 还是没有养成写点东西的习惯，许多东西学得快，忘得也快。还有一些算法或者什么思想啦，只在脑中形成一些概念而已，没有经过系统的思考，慢慢也会忘掉的。记笔记尤其是写markdown，总能梳理出一个清晰的思路来。就比如过年之前花费了十几天","text":"今天是大年初五，2010.1.29， 在家连续玩了四天了，要开始继续学习了呀。 自从电脑从linux 换成 windows ，就没有再重新配置hexo的环境（说白了太懒了），昨天折腾了一整天，把电脑里的文件整理、清理，升级或者卸载不用的软件，外加更新几个linux的虚拟机，整整折腾了一整天。昨天又下了nodejs，重新搞了一下hexo，继续写吧，每天学学学，总得留下什么吧。 还是没有养成写点东西的习惯，许多东西学得快，忘得也快。还有一些算法或者什么思想啦，只在脑中形成一些概念而已，没有经过系统的思考，慢慢也会忘掉的。记笔记尤其是写markdown，总能梳理出一个清晰的思路来。就比如过年之前花费了十几天学习了java的SSM框架，虽然学了写了好多，但是现在就感觉全部忘掉了····· 也许是记忆力也出了点小问题叭。不管怎样，我还是要记下来，每天都记一记。 首先还是要好好反思自己，作为一名现役的ACM队员，19年下半年做的题量还不如我大一的一个月做的多，这是非常不正常的，银川回来之后，原想努把力去上海冲个金，结果才拿了铜，ccpc-final和ec-final相继打铁。想想也是太丢人了，我的状态不对呀！ 及时改变自己吧，生活还是可以回到正轨上来的。下个赛季，大四再打一个赛季，把在赛场上丢的脸捡回来，证明自己。 确实不应该，放弃了最好的一个学期去做了自己都知道没有结果的事情。冷静下来一想，是自己没有把握好度，失去了理智像飞蛾扑火般，不管怎样，都是一段很好的回忆叭。 自己也是在不断成长的呢，明白了许多的道理，看到了自己以前没有看到的方面，知道了自己的不足，也算是一种提高，一种阅历吧。 总之，悟已往之不谏，知来者之可追！！ 1000题的小目标还没开始做呢，不要老想着明天啦，明日复明日，明日何其多嘛，现在就开始！ 我的数论模版还没整理完呢，希望能在开学前整理完~~ java的SSM框架的工程才写了一半，希望也能抽空写完~~（idea intellij 太好用了，吹爆！jb-mono字体也很棒哦） 昨天晚上突然看了一眼 .net , 学着用c#写了一个hello world，感觉还挺有意思，希望能有空学一学~~ 当然 linux内核的源码也想学学，这本书放桌面上几个月了还没看…… 还是挺多东西学习的，继续加油叭，奥利给！！ 奥利给！！","categories":[{"name":"日常碎碎念","slug":"日常碎碎念","permalink":"https://yanghaku.github.io/categories/%E6%97%A5%E5%B8%B8%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[],"author":"yb"},{"title":"2019东北地区四省赛","slug":"2019东北地区四省赛","date":"2019-05-22T06:00:00.000Z","updated":"2019-06-04T13:31:37.000Z","comments":true,"path":"2019/05/22/2019东北地区四省赛/","link":"","permalink":"https://yanghaku.github.io/2019/05/22/2019%E4%B8%9C%E5%8C%97%E5%9C%B0%E5%8C%BA%E5%9B%9B%E7%9C%81%E8%B5%9B/","excerpt":"题目pdf链接 提交链接(codeforces)","text":"题目pdf链接 提交链接(codeforces) 在现场(我)写崩了C题，虽然最后救回来了（队友带飞），但是还差一点，差一题才到金 概览： A. Apple Business B. Balanced Diet C. Line-line Intersection D. Master of Data Structure E. Minimum Spanning Tree F. Mini-game Before Contest G. Radar Scanner H. Skyscraper I. Temperature Survey J. Time Limit A. Apple Business pending（暂时不会） B. Balanced Diet 题意：给你n个糖果，每个糖果有价值$a_i$,属于种类$b_i$,让选择一些糖果，使得 (总价值/选择种类最大的个数) 尽量大，第j种糖果如果选择，选择的个数就应该大于等于$l_j$,(1","categories":[{"name":"现场赛の补题","slug":"现场赛の补题","permalink":"https://yanghaku.github.io/categories/%E7%8E%B0%E5%9C%BA%E8%B5%9B%E3%81%AE%E8%A1%A5%E9%A2%98/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://yanghaku.github.io/tags/codeforces/"}],"author":"yb"},{"title":"2018-2019 ICPC, NEERC, Southern Subregional Contest ","slug":"2018-2019-ICPC-NEERC-Southern-Subregional-Contest","date":"2019-05-20T00:54:00.000Z","updated":"2020-01-29T02:25:45.829Z","comments":true,"path":"2019/05/20/2018-2019-ICPC-NEERC-Southern-Subregional-Contest/","link":"","permalink":"https://yanghaku.github.io/2019/05/20/2018-2019-ICPC-NEERC-Southern-Subregional-Contest/","excerpt":"这套题目难度适中吧，只不过我们队还没做到自己的最好，自闭了好几个小时的题目竟然是水题 题目pdf链接 codeforce提交链接","text":"这套题目难度适中吧，只不过我们队还没做到自己的最好，自闭了好几个小时的题目竟然是水题 题目pdf链接 codeforce提交链接 概览： A. Find a Number B. Berkomnadzor C. Cloud Computing D. Garbage Disposal E. Getting Deals Done F. Debate G. Monsters and Potions H. BerOS File Suggestion I. Privatization of Roads in Berland J. Streets and Avenues in Berhattan K. Video Posts L. Odd Federalization M. Algoland and Berland A. Find a Number 题目大意： 给你一个d(1&lt;=d&lt;=500),和s(1&lt;=s&lt;=5000)，找到一个最小的整数n使得n是d的倍数并且各数位之和为s，不存在就输出-1。 这个题自闭了四个小时还没做出来，其实就是一个简单的bfs！！ 思路：记 dp[x][y] 为余数为x，各数位之和为y的数的最小值，因为数位太大，所以可以用一个string保存。状态转移方程是： dp[(x10+k)%d][y+k]=dp[x][y]+string(k) (0&lt;=k&lt;=9) //其中＋为字符串的连接操作。所以只要找到dp[0][s]即可，初始的状态为dp[k%d][k] (1&lt;=k&lt;=9) (即只有一位的时候） 直接用记忆化的BFS搜索即可，而且这样可以保证每次第一次访问到的状态都是最小的，因为加入队列的顺序是*从小到大**的。（有一个与此题非常相似的题，就是因为这个从小到大的特性才能AC–&gt;题目链接：Enigma）。 ac代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;int d,S;//string str[501][5001];bool vis[501][5001];struct T&#123; int x,y; string s; T(int xx,int yy,string ss):x(xx),y(yy),s(ss)&#123;&#125;&#125;;queue&lt;T&gt;q;int solve()&#123; while(!q.empty())q.pop(); for(int i=1;i&lt;10;++i)&#123; q.emplace(i%d,i,string(1,char(i+'0'))); vis[i%d][i]=1; &#125; while(!q.empty())&#123; int x=q.front().x; int y=q.front().y; string s=q.front().s; q.pop(); if(x==0&amp;&amp;y==S)&#123; cout&lt;&lt;s&lt;&lt;endl; return 0; &#125; for(int i=0;i&lt;10;++i)&#123; if(y+i&gt;S)continue; int id=(x*10+i)%d; if(vis[id][y+i]==0)&#123; vis[id][y+i]=1; q.emplace(id,y+i,s+char(i+'0')); &#125; &#125; &#125; return 1;&#125;int main()&#123; cin&gt;&gt;d&gt;&gt;S; if(solve())cout&lt;&lt;\"-1\"&lt;&lt;endl; return 0;&#125; 优化： 上面的代码跑了1200多ms，虽说没有超时，但是还是完全可以优化的。考虑到每次的状态都需要一个string保存，每次状态转移都是前一个的string复制后再添上一个字符（而其中的复制和动态内存的分配与释放消耗的时间非常多），所以说这个地方可以有很大的优化。考虑到每次状态转移都是只添加一个字符，而其他字符就可以直接用上一个状态的就行，所以可以做成一个链表，每一个状态都保存它上一个状态的地址（两个坐标），就能生成最后的字符串，这样可以节省所有的字符串复制的时间。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;int d,S;//string str[501][5001];bool vis[501][5001];int lastx[501][5001],lasty[501][5001];char ch[501][5001];struct T&#123; int x,y; T(int xx,int yy):x(xx),y(yy)&#123;&#125;&#125;;queue&lt;T&gt;q;void getString(int x,int y)&#123; string s=\"\"; int tmp; while(x!=-1)&#123; s=s+ch[x][y]; tmp=lastx[x][y]; y=lasty[x][y]; x=tmp; &#125; reverse(s.begin(),s.end()); cout&lt;&lt;s&lt;&lt;endl;&#125;int solve()&#123; while(!q.empty())q.pop(); for(int i=1;i&lt;10;++i)&#123; q.emplace(i%d,i); vis[i%d][i]=1; lastx[i%d][i]=-1; lasty[i%d][i]=-1; ch[i%d][i]=i+'0'; &#125; while(!q.empty())&#123; int x=q.front().x; int y=q.front().y; q.pop(); if(x==0&amp;&amp;y==S)&#123; getString(x,y); return 0; &#125; for(int i=0;i&lt;10;++i)&#123; if(y+i&gt;S)continue; int id=(x*10+i)%d; if(vis[id][y+i]==0)&#123; vis[id][y+i]=1; q.emplace(id,y+i); ch[id][y+i]=i+'0'; lastx[id][y+i]=x; lasty[id][y+i]=y; &#125; &#125; &#125; return 1;&#125;int main()&#123; cin&gt;&gt;d&gt;&gt;S; if(solve())cout&lt;&lt;\"-1\"&lt;&lt;endl; return 0;&#125; 两次运行时间对比：(可以发现少了将近1s） B. Berkomnadzor (mid) 字典树大模拟，题目大意：给你n个ip地址(也可能是一个划分的子网）都是使用点分十进制表示法，这n个ip有的属于白名单，有的属于黑名单，然后就是让你把黑名单合并，要求在白名单中的不能属于黑名单，不在白名单中的ip也可以进入黑名单，让你合并后的黑名单个数尽量少。（如果某个ip既在黑名单又在白名单，那么就输出-1。 思路：首先写好点分十进制和二进制ip的相互转化函数，字典树里面只包括0,1字符即可，每个节点要维护当前ip地址(或者子网)是否属于黑名单或者白名单，当前节点之后的子网有没有属于白名单的，有没有属于黑名单的即可。检查冲突：如果下面的所有子网地址都属于一个确定的黑(白)名单，那么就可以判断是否与当前正在插入的ip有冲突，如果到达当前ip的子网掩码长度，就可以判断下面的子网中有没有与此冲突。 注意有子网掩码为0的情况，也就是包括所有的ip的情况。 ac代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char buf[30];int ip[100],white;int len,subnet_len,ans,black_num=0;struct node&#123; node* next[2]; bool has_white[2]; bool has_black[2]; bool all_white; bool all_black; node()&#123; memset(next,0,sizeof(next)); memset(has_white,0,sizeof(has_white)); memset(has_black,0,sizeof(has_black)); all_white=all_black=0; &#125; ~node()&#123; if(next[0])delete next[0]; if(next[1])delete next[1]; &#125;&#125;*root;void get_binary()&#123;//将点分十进制变为二进制 if(buf[0]=='+')white=1; else white=0,++black_num; len=strlen(buf); int tot=0; subnet_len=32; for(int i=1;i&lt;len;++i)&#123; int x=0; while(i&lt;len&amp;&amp;buf[i]&gt;='0'&amp;&amp;buf[i]&lt;='9')&#123; x=x*10+buf[i]-'0'; ++i; &#125; if(tot==32)&#123; subnet_len=x; break; &#125; for(int k=0;k&lt;8;++k)&#123; if((x&gt;&gt;(7-k))&amp;1)ip[tot]=1; else ip[tot]=0; ++tot; &#125; &#125;&#125;void change_binary()&#123;//将二进制变为点分十进制 for(int i=0;i&lt;4;++i)&#123; int x=0; for(int j=i*8;j&lt;(i+1)*8&amp;&amp;j&lt;subnet_len;++j)&#123; x=x|(ip[j]&lt;&lt;(7-j+i*8)); &#125; printf(\"%d\",x); if(i==3)&#123; if(subnet_len!=32)printf(\"/%d\\n\",subnet_len); else printf(\"\\n\"); &#125; else printf(\".\"); &#125;&#125;bool insert()&#123; node* p=root; if(subnet_len==0)&#123; if(white)&#123; if(p-&gt;has_black[0]||p-&gt;has_black[1]||p-&gt;all_black)return false; p-&gt;all_white=1; &#125; else&#123; if(p-&gt;has_white[0]||p-&gt;has_white[1]||p-&gt;all_white)return false; p-&gt;all_black=1; &#125; return 1; &#125; for(int i=0;i&lt;32;++i)&#123; if(white)p-&gt;has_white[ip[i]]=1; else p-&gt;has_black[ip[i]]=1; if(!p-&gt;next[ip[i]])p-&gt;next[ip[i]]=new node(); p=p-&gt;next[ip[i]]; if(p-&gt;all_white)&#123; if(white)break; return false;//黑白冲突 &#125; if(p-&gt;all_black)&#123; if(white)return false; break; &#125; if(i==subnet_len-1)&#123; if(white)&#123; p-&gt;all_white=1; if(p-&gt;has_black[0]||p-&gt;has_black[1])return false; &#125; else&#123; p-&gt;all_black=1; if(p-&gt;has_white[0]||p-&gt;has_white[1])return false; &#125; break; &#125; &#125; return 1;&#125;void dfs_num(node* now,int num)&#123; if(now-&gt;all_white)return; if(now-&gt;all_black|| (!now-&gt;has_white[0]&amp;&amp;!now-&gt;has_white[1]))&#123; ++ans; return; &#125; if(now-&gt;next[0])&#123; ip[num]=0; dfs_num(now-&gt;next[0],num+1); &#125; if(now-&gt;next[1])&#123; ip[num]=1; dfs_num(now-&gt;next[1],num+1); &#125;&#125;void dfs(node* now,int num)&#123; if(now-&gt;all_white)return; if(now-&gt;all_black || (!now-&gt;has_white[0]&amp;&amp;!now-&gt;has_white[1]))&#123; subnet_len=num; change_binary(); return; &#125; if(now-&gt;next[0])&#123; ip[num]=0; dfs(now-&gt;next[0],num+1); &#125; if(now-&gt;next[1])&#123; ip[num]=1; dfs(now-&gt;next[1],num+1); &#125;&#125;int main()&#123; root=new node(); int n;cin&gt;&gt;n; while(n--)&#123; scanf(\"%s\",buf); get_binary(); if(!insert())&#123; cout&lt;&lt;\"-1\"&lt;&lt;endl; return 0; &#125; &#125; if(black_num==0)&#123; cout&lt;&lt;\"-1\"&lt;&lt;endl; return 0; &#125; ans=0; dfs_num(root,0); cout&lt;&lt;ans&lt;&lt;endl; dfs(root,0); delete root; return 0;&#125; C. Cloud Computing pending D. Garbage Disposal 签到题一枚，题目大意是给你n天的每天的垃圾量，每个垃圾只能在当天或者第二天扔掉（不能放到第三天），垃圾只能装到包里才能扔，所以给你一个k，表示每个包最多能盛放多少垃圾。问最小需要多少个包。思路：直接贪心即可，每天把当天需要扔的垃圾整除k（装包扔掉），余数（即剩下不够装满一个包）就放到第二天扔。但是要注意垃圾不能存到第三天，所以只要保证当天扔的垃圾大于前一天剩下的即可。ac代码： 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;int main()&#123; long long n,k,last=0,a,ans=0,tmp; cin&gt;&gt;n&gt;&gt;k; while(n--)&#123; cin&gt;&gt;a; a+=last; tmp=a/k; a%=k; if(tmp*k&lt;last)&#123; //如果当天扔的小于昨天剩下的，也要强制扔去 ++tmp; a=0; &#125; ans+=tmp; last=a; &#125; if(last)++ans;//如果最后还剩下，就直接装包扔掉 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; E. Getting Deals Done pending F. Debate 题目大意：给你n（1","categories":[{"name":"平时训练の补题","slug":"平时训练の补题","permalink":"https://yanghaku.github.io/categories/%E5%B9%B3%E6%97%B6%E8%AE%AD%E7%BB%83%E3%81%AE%E8%A1%A5%E9%A2%98/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://yanghaku.github.io/tags/codeforces/"}],"author":"yb"},{"title":"my first blog","slug":"my-first-blog","date":"2019-05-20T00:30:00.000Z","updated":"2019-05-20T00:52:33.000Z","comments":true,"path":"2019/05/20/my-first-blog/","link":"","permalink":"https://yanghaku.github.io/2019/05/20/my-first-blog/","excerpt":"从现在开始，2019.5.20，我将拥有自己的博客了。 对我来说写博客的用处有一下几点：","text":"从现在开始，2019.5.20，我将拥有自己的博客了。 对我来说写博客的用处有一下几点： 每天总结自己做过的题目，加深思考。 为自己写过的代码做备份，之前一直保存在本地，虽然都用文件夹做了分类，但是还是查找不方便，而且有时又懒得保存。 克服自己的懒惰，到了现在，看了自己的github，自己已经有半年没有好好写代码了，不仅仅是手懒，脑子也变得懒了，记得前几天教练还说过：我们已经停止了思考。对，就是停止了思考！现在的程度，是对许多的算法都知道，但是却不能静下心来仔细研究其中的原理和更深层的应用。没有了思考，也就没有了提高，只靠板子是做不了题的！ 所以从此，加油，克服自己的懒惰，才能提高！ 博客名字以后再想吧……","categories":[],"tags":[],"author":"yb"}]}