{"meta":{"title":"YangBo","subtitle":"奋斗才能拥有最美丽的人生","description":"一个快废掉的咸鱼罢了","author":"杨博","url":"https://yanghaku.github.io","root":"/"},"pages":[{"title":"about the author of this blog","date":"2019-05-17T05:29:39.000Z","updated":"2019-05-20T16:04:29.000Z","comments":false,"path":"about/index.html","permalink":"https://yanghaku.github.io/about/index.html","excerpt":"","text":"github: yanghaku qq: 1961882079 school: neu"},{"title":"categories","date":"2019-05-20T16:01:56.000Z","updated":"2019-05-20T16:04:45.000Z","comments":false,"path":"categories/index.html","permalink":"https://yanghaku.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-20T16:05:36.000Z","updated":"2019-05-20T16:05:59.000Z","comments":false,"path":"tags/index.html","permalink":"https://yanghaku.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":".NET初学概览","slug":"NET概览","date":"2020-01-29T08:46:51.000Z","updated":"2020-01-29T13:31:07.089Z","comments":true,"path":"2020/01/29/NET概览/","link":"","permalink":"https://yanghaku.github.io/2020/01/29/NET%E6%A6%82%E8%A7%88/","excerpt":"主要是对 .NET Core, .NET Standard, .NET framework 和 Xamarin 的介绍和区分 并且介绍一下其中的ASP.NET, UWP， XAMARIN 等 然后就是 .NET 的未来： .NET 5 （2019年5月宣布的下一代的版本），将把前面这些运行时全部合为一体 以前刚开始听说 .NET 的时候，我只知道 .NET framework , 然后昨天看了一眼官网的 .NET 入门学习的时候吗，又看到了 .NET Core, 然后各种名词接踵而来，有点懵，所以就总结了一下下。","text":"主要是对 .NET Core, .NET Standard, .NET framework 和 Xamarin 的介绍和区分 并且介绍一下其中的ASP.NET, UWP， XAMARIN 等 然后就是 .NET 的未来： .NET 5 （2019年5月宣布的下一代的版本），将把前面这些运行时全部合为一体 以前刚开始听说 .NET 的时候，我只知道 .NET framework , 然后昨天看了一眼官网的 .NET 入门学习的时候吗，又看到了 .NET Core, 然后各种名词接踵而来，有点懵，所以就总结了一下下。 首先就是当下的框架图： .NET广义的 .NET 是一个通用的开发平台，能够跨语言，跨平台 ，能够支持跨多个平台的方案 .NET 开发可以实现包括 .NET Framework、.NET Core 和 Mono。 .NET 的所有实现都有一个名为 .NET Standard 的通用 API 规范。 .NET 与 java 对比理解： .NET 与 java有很多相似的地方，两者都是即时编译语言（JIT）， 项目编译生成的文件不是具体的机器码，而是中间语言。 在java里面叫做字节码（bytecode）， 而在 .NET里面叫做中间语言（Common Intermediate Language，简称 IL），java官方运行环境是java的虚拟机JRE（Java Runtime Environment）， 而在 .NET 官方运行环境叫做公共语言运行时（Common Language Runtime， 简称CLR） 这是 .NET 跨语言，跨平台的基础 跨语言： c#， f#， VB.NET 这些面向 .NET 的都可以 跨平台： 开发 Windows，Linux，macOS，iOS，Android，tvOS，watchOS 和 WebAssembly .NET framework传统的 .NET framework 是以一种采用CLR 为基础，支持多种语言（c#，f#，VB.NET, c++，Python等）的开发。 这也是我们用到的最多最熟悉的 .NET , 这个缺点就是不能跨平台，只能在windows上用。一般就是用来做桌面应用程序和ASP.NET的. .NET Core主要是针对windows，linux，macOS，服务器和控制台应用程序的跨平台 .NET 实现 它支持四种应用程序：控制台，ASP.NET Core, 云 和通用windows平台( UWP ) 需要注意的是: 尽管微软把 .NET Core作为.NET未来的发展方向，但 .NET Core和 .NET Framework 仍然是两个独立的产品。.NET Framework也会继续更新和维护。 .NET Core 不再是windows 专门的，在其他平台也可以用。 就是为了跨平台而做的，不是windows的一个组件了。 .NET Standard.NET Standard 是一组由.NET 实现的基本的API集。 是一个进一步实现跨平台跨设备的代码共享。其实是未来 .NET的核心，一切基于它来实现代码共享。 .NET Standard 和 .NET 之间 相当于html 规范和 浏览器之间的关系，后者是前者的实现。 Xamarin 与 MonoMono是 .NET 开源之前的一个跨平台的方案，是由Xamarin公司主持的开源项目，可以运行于Linux等其他平台 （于2016年被微软收购）。相当于实现了各个平台上的 .NET 的公共语言运行时（CLR）。 现在主要运用在移动设备，许多著名的游戏引擎比如Unity3D也包含着这个技术。 对于IOS和Android 应用程序，Xamarin 将 .NET 技术代入里面， 成为唯一一个能够提供跨iOS，Android和windowsPhone 的单一语言平台。 ASP.NET 和 ASP.NET Core这两个只是以上框架里的一个小组件，用于开发Web应用程序。 然后两个的区别就是ASP.NET 是 .NET framework 里的组件， 只有windows版本的API 而ASP.NET Core 是 .NET Core 的组件，是对于跨平台准备的，是 ASP.NET 的跨平台版本。 所以说以上这么多的名词，都是因为不断进化产生的，从只有一个 .NET framework 只支持windows平台，到后来的跨平台的方案，都在慢慢发展来的。 三个框架与应用总结所以再回顾一下上面的那个图片: 现在主要的三个框架实现 .NET Framework （最新到4.8版本）主要是对windows平台的 .NET Core （最新到3.1版本）可以跨平台，主要是一些控制台设备，如linux，windows，macOS等 XAMARIN 主要是针对移动设备的，比如Android，iOS等 官网文档上说的： There are various implementations of .NET. Each implementation allows .NET code to execute in different places—Linux, macOS, Windows, iOS, Android, and many more. .NET Framework is the original implementation of .NET. It supports running websites, services, desktop apps, and more on Windows. .NET Core is a cross-platform implementation for running websites, services, and console apps on Windows, Linux, and macOS. .NET Core is open source on GitHub. Xamarin/Mono is a .NET implementation for running apps on all the major mobile operating systems, including iOS and Android. .NET Standard is a formal specification of the APIs that are common across .NET implementations. This allows the same code and libraries to run on different implementations. .NET 5 未来的展望现在这么多的框架什么的，到了 .NET5 将会融为一体。 .NET 5 将会融合 .NET Framework , .NET Core, Mono, Xamarin 等优点构建出一个统一的 .NET 平台，开发人员可以使用 C#， VB.NET, F# 等语言，使用相同的API 开发针对任何系统，任何架构，任何形态的应用程序，并且代码和库均可通过 .NET Standard 共享 。 也就是说，到了那个时候开发出一个应用程序，就可以全平台通吃，只要有一个 .NET, 就能一次开发出适用于Windows，Linux，macOS，iOS，Android，tvOS，watchOS 和 WebAssembly 等所有平台的应用程序了。 希望早日到来，让俺们这些开发人员感受感受叭。 2019年5月微软宣布的.NET5， 将会在 2020年11月发布 参考链接： .NET:持续进化的统一开发平台 .NET Core和.NET Standard有什么不同 (翻译)正式宣布 .NET 5","categories":[{"name":".NET学习","slug":"NET学习","permalink":"https://yanghaku.github.io/categories/NET%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"失踪半年人口回归","slug":"失踪半年人口回归","date":"2020-01-29T03:00:00.000Z","updated":"2020-01-29T13:29:00.195Z","comments":true,"path":"2020/01/29/失踪半年人口回归/","link":"","permalink":"https://yanghaku.github.io/2020/01/29/%E5%A4%B1%E8%B8%AA%E5%8D%8A%E5%B9%B4%E4%BA%BA%E5%8F%A3%E5%9B%9E%E5%BD%92/","excerpt":"今天是大年初五，2010.1.29， 在家连续玩了四天了，要开始继续学习了呀。 自从电脑从linux 换成 windows ，就没有再重新配置hexo的环境（说白了太懒了），昨天折腾了一整天，把电脑里的文件整理、清理，升级或者卸载不用的软件，外加更新几个linux的虚拟机，整整折腾了一整天。昨天又下了nodejs，重新搞了一下hexo，继续写吧，每天学学学，总得留下什么吧。 还是没有养成写点东西的习惯，许多东西学得快，忘得也快。还有一些算法或者什么思想啦，只在脑中形成一些概念而已，没有经过系统的思考，慢慢也会忘掉的。记笔记尤其是写markdown，总能梳理出一个清晰的思路来。就比如过年之前花费了十几天","text":"今天是大年初五，2010.1.29， 在家连续玩了四天了，要开始继续学习了呀。 自从电脑从linux 换成 windows ，就没有再重新配置hexo的环境（说白了太懒了），昨天折腾了一整天，把电脑里的文件整理、清理，升级或者卸载不用的软件，外加更新几个linux的虚拟机，整整折腾了一整天。昨天又下了nodejs，重新搞了一下hexo，继续写吧，每天学学学，总得留下什么吧。 还是没有养成写点东西的习惯，许多东西学得快，忘得也快。还有一些算法或者什么思想啦，只在脑中形成一些概念而已，没有经过系统的思考，慢慢也会忘掉的。记笔记尤其是写markdown，总能梳理出一个清晰的思路来。就比如过年之前花费了十几天学习了java的SSM框架，虽然学了写了好多，但是现在就感觉全部忘掉了····· 也许是记忆力也出了点小问题叭。不管怎样，我还是要记下来，每天都记一记。 首先还是要好好反思自己，作为一名现役的ACM队员，19年下半年做的题量还不如我大一的一个月做的多，这是非常不正常的，银川回来之后，原想努把力去上海冲个金，结果才拿了铜，ccpc-final和ec-final相继打铁。想想也是太丢人了，我的状态不对呀！ 及时改变自己吧，生活还是可以回到正轨上来的。下个赛季，大四再打一个赛季，把在赛场上丢的脸捡回来，证明自己。 确实不应该，放弃了最好的一个学期去做了自己都知道没有结果的事情。冷静下来一想，是自己没有把握好度，失去了理智像飞蛾扑火般，不管怎样，都是一段很好的回忆叭。 自己也是在不断成长的呢，明白了许多的道理，看到了自己以前没有看到的方面，知道了自己的不足，也算是一种提高，一种阅历吧。 总之，悟已往之不谏，知来者之可追！！ 1000题的小目标还没开始做呢，不要老想着明天啦，明日复明日，明日何其多嘛，现在就开始！ 我的数论模版还没整理完呢，希望能在开学前整理完~~ java的SSM框架的工程才写了一半，希望也能抽空写完~~（idea intellij 太好用了，吹爆！jb-mono字体也很棒哦） 昨天晚上突然看了一眼 .net , 学着用c#写了一个hello world，感觉还挺有意思，希望能有空学一学~~ 当然 linux内核的源码也想学学，这本书放桌面上几个月了还没看…… 还是挺多东西学习的，继续加油叭，奥利给！！ 奥利给！！","categories":[{"name":"日常碎碎念","slug":"日常碎碎念","permalink":"https://yanghaku.github.io/categories/%E6%97%A5%E5%B8%B8%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[],"author":"yb"},{"title":"2019东北地区四省赛","slug":"2019东北地区四省赛","date":"2019-05-22T06:00:00.000Z","updated":"2019-06-04T13:31:37.000Z","comments":true,"path":"2019/05/22/2019东北地区四省赛/","link":"","permalink":"https://yanghaku.github.io/2019/05/22/2019%E4%B8%9C%E5%8C%97%E5%9C%B0%E5%8C%BA%E5%9B%9B%E7%9C%81%E8%B5%9B/","excerpt":"题目pdf链接 提交链接(codeforces)","text":"题目pdf链接 提交链接(codeforces) 在现场(我)写崩了C题，虽然最后救回来了（队友带飞），但是还差一点，差一题才到金 概览： A. Apple Business B. Balanced Diet C. Line-line Intersection D. Master of Data Structure E. Minimum Spanning Tree F. Mini-game Before Contest G. Radar Scanner H. Skyscraper I. Temperature Survey J. Time Limit A. Apple Business pending（暂时不会） B. Balanced Diet 题意：给你n个糖果，每个糖果有价值$a_i$,属于种类$b_i$,让选择一些糖果，使得 (总价值/选择种类最大的个数) 尽量大，第j种糖果如果选择，选择的个数就应该大于等于$l_j$,(1","categories":[{"name":"现场赛の补题","slug":"现场赛の补题","permalink":"https://yanghaku.github.io/categories/%E7%8E%B0%E5%9C%BA%E8%B5%9B%E3%81%AE%E8%A1%A5%E9%A2%98/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://yanghaku.github.io/tags/codeforces/"}],"author":"yb"},{"title":"2018-2019 ICPC, NEERC, Southern Subregional Contest ","slug":"2018-2019-ICPC-NEERC-Southern-Subregional-Contest","date":"2019-05-20T00:54:00.000Z","updated":"2020-01-29T02:25:45.829Z","comments":true,"path":"2019/05/20/2018-2019-ICPC-NEERC-Southern-Subregional-Contest/","link":"","permalink":"https://yanghaku.github.io/2019/05/20/2018-2019-ICPC-NEERC-Southern-Subregional-Contest/","excerpt":"这套题目难度适中吧，只不过我们队还没做到自己的最好，自闭了好几个小时的题目竟然是水题 题目pdf链接 codeforce提交链接","text":"这套题目难度适中吧，只不过我们队还没做到自己的最好，自闭了好几个小时的题目竟然是水题 题目pdf链接 codeforce提交链接 概览： A. Find a Number B. Berkomnadzor C. Cloud Computing D. Garbage Disposal E. Getting Deals Done F. Debate G. Monsters and Potions H. BerOS File Suggestion I. Privatization of Roads in Berland J. Streets and Avenues in Berhattan K. Video Posts L. Odd Federalization M. Algoland and Berland A. Find a Number 题目大意： 给你一个d(1&lt;=d&lt;=500),和s(1&lt;=s&lt;=5000)，找到一个最小的整数n使得n是d的倍数并且各数位之和为s，不存在就输出-1。 这个题自闭了四个小时还没做出来，其实就是一个简单的bfs！！ 思路：记 dp[x][y] 为余数为x，各数位之和为y的数的最小值，因为数位太大，所以可以用一个string保存。状态转移方程是： dp[(x10+k)%d][y+k]=dp[x][y]+string(k) (0&lt;=k&lt;=9) //其中＋为字符串的连接操作。所以只要找到dp[0][s]即可，初始的状态为dp[k%d][k] (1&lt;=k&lt;=9) (即只有一位的时候） 直接用记忆化的BFS搜索即可，而且这样可以保证每次第一次访问到的状态都是最小的，因为加入队列的顺序是*从小到大**的。（有一个与此题非常相似的题，就是因为这个从小到大的特性才能AC–&gt;题目链接：Enigma）。 ac代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;int d,S;//string str[501][5001];bool vis[501][5001];struct T&#123; int x,y; string s; T(int xx,int yy,string ss):x(xx),y(yy),s(ss)&#123;&#125;&#125;;queue&lt;T&gt;q;int solve()&#123; while(!q.empty())q.pop(); for(int i=1;i&lt;10;++i)&#123; q.emplace(i%d,i,string(1,char(i+'0'))); vis[i%d][i]=1; &#125; while(!q.empty())&#123; int x=q.front().x; int y=q.front().y; string s=q.front().s; q.pop(); if(x==0&amp;&amp;y==S)&#123; cout&lt;&lt;s&lt;&lt;endl; return 0; &#125; for(int i=0;i&lt;10;++i)&#123; if(y+i&gt;S)continue; int id=(x*10+i)%d; if(vis[id][y+i]==0)&#123; vis[id][y+i]=1; q.emplace(id,y+i,s+char(i+'0')); &#125; &#125; &#125; return 1;&#125;int main()&#123; cin&gt;&gt;d&gt;&gt;S; if(solve())cout&lt;&lt;\"-1\"&lt;&lt;endl; return 0;&#125; 优化： 上面的代码跑了1200多ms，虽说没有超时，但是还是完全可以优化的。考虑到每次的状态都需要一个string保存，每次状态转移都是前一个的string复制后再添上一个字符（而其中的复制和动态内存的分配与释放消耗的时间非常多），所以说这个地方可以有很大的优化。考虑到每次状态转移都是只添加一个字符，而其他字符就可以直接用上一个状态的就行，所以可以做成一个链表，每一个状态都保存它上一个状态的地址（两个坐标），就能生成最后的字符串，这样可以节省所有的字符串复制的时间。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;int d,S;//string str[501][5001];bool vis[501][5001];int lastx[501][5001],lasty[501][5001];char ch[501][5001];struct T&#123; int x,y; T(int xx,int yy):x(xx),y(yy)&#123;&#125;&#125;;queue&lt;T&gt;q;void getString(int x,int y)&#123; string s=\"\"; int tmp; while(x!=-1)&#123; s=s+ch[x][y]; tmp=lastx[x][y]; y=lasty[x][y]; x=tmp; &#125; reverse(s.begin(),s.end()); cout&lt;&lt;s&lt;&lt;endl;&#125;int solve()&#123; while(!q.empty())q.pop(); for(int i=1;i&lt;10;++i)&#123; q.emplace(i%d,i); vis[i%d][i]=1; lastx[i%d][i]=-1; lasty[i%d][i]=-1; ch[i%d][i]=i+'0'; &#125; while(!q.empty())&#123; int x=q.front().x; int y=q.front().y; q.pop(); if(x==0&amp;&amp;y==S)&#123; getString(x,y); return 0; &#125; for(int i=0;i&lt;10;++i)&#123; if(y+i&gt;S)continue; int id=(x*10+i)%d; if(vis[id][y+i]==0)&#123; vis[id][y+i]=1; q.emplace(id,y+i); ch[id][y+i]=i+'0'; lastx[id][y+i]=x; lasty[id][y+i]=y; &#125; &#125; &#125; return 1;&#125;int main()&#123; cin&gt;&gt;d&gt;&gt;S; if(solve())cout&lt;&lt;\"-1\"&lt;&lt;endl; return 0;&#125; 两次运行时间对比：(可以发现少了将近1s） B. Berkomnadzor (mid) 字典树大模拟，题目大意：给你n个ip地址(也可能是一个划分的子网）都是使用点分十进制表示法，这n个ip有的属于白名单，有的属于黑名单，然后就是让你把黑名单合并，要求在白名单中的不能属于黑名单，不在白名单中的ip也可以进入黑名单，让你合并后的黑名单个数尽量少。（如果某个ip既在黑名单又在白名单，那么就输出-1。 思路：首先写好点分十进制和二进制ip的相互转化函数，字典树里面只包括0,1字符即可，每个节点要维护当前ip地址(或者子网)是否属于黑名单或者白名单，当前节点之后的子网有没有属于白名单的，有没有属于黑名单的即可。检查冲突：如果下面的所有子网地址都属于一个确定的黑(白)名单，那么就可以判断是否与当前正在插入的ip有冲突，如果到达当前ip的子网掩码长度，就可以判断下面的子网中有没有与此冲突。 注意有子网掩码为0的情况，也就是包括所有的ip的情况。 ac代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char buf[30];int ip[100],white;int len,subnet_len,ans,black_num=0;struct node&#123; node* next[2]; bool has_white[2]; bool has_black[2]; bool all_white; bool all_black; node()&#123; memset(next,0,sizeof(next)); memset(has_white,0,sizeof(has_white)); memset(has_black,0,sizeof(has_black)); all_white=all_black=0; &#125; ~node()&#123; if(next[0])delete next[0]; if(next[1])delete next[1]; &#125;&#125;*root;void get_binary()&#123;//将点分十进制变为二进制 if(buf[0]=='+')white=1; else white=0,++black_num; len=strlen(buf); int tot=0; subnet_len=32; for(int i=1;i&lt;len;++i)&#123; int x=0; while(i&lt;len&amp;&amp;buf[i]&gt;='0'&amp;&amp;buf[i]&lt;='9')&#123; x=x*10+buf[i]-'0'; ++i; &#125; if(tot==32)&#123; subnet_len=x; break; &#125; for(int k=0;k&lt;8;++k)&#123; if((x&gt;&gt;(7-k))&amp;1)ip[tot]=1; else ip[tot]=0; ++tot; &#125; &#125;&#125;void change_binary()&#123;//将二进制变为点分十进制 for(int i=0;i&lt;4;++i)&#123; int x=0; for(int j=i*8;j&lt;(i+1)*8&amp;&amp;j&lt;subnet_len;++j)&#123; x=x|(ip[j]&lt;&lt;(7-j+i*8)); &#125; printf(\"%d\",x); if(i==3)&#123; if(subnet_len!=32)printf(\"/%d\\n\",subnet_len); else printf(\"\\n\"); &#125; else printf(\".\"); &#125;&#125;bool insert()&#123; node* p=root; if(subnet_len==0)&#123; if(white)&#123; if(p-&gt;has_black[0]||p-&gt;has_black[1]||p-&gt;all_black)return false; p-&gt;all_white=1; &#125; else&#123; if(p-&gt;has_white[0]||p-&gt;has_white[1]||p-&gt;all_white)return false; p-&gt;all_black=1; &#125; return 1; &#125; for(int i=0;i&lt;32;++i)&#123; if(white)p-&gt;has_white[ip[i]]=1; else p-&gt;has_black[ip[i]]=1; if(!p-&gt;next[ip[i]])p-&gt;next[ip[i]]=new node(); p=p-&gt;next[ip[i]]; if(p-&gt;all_white)&#123; if(white)break; return false;//黑白冲突 &#125; if(p-&gt;all_black)&#123; if(white)return false; break; &#125; if(i==subnet_len-1)&#123; if(white)&#123; p-&gt;all_white=1; if(p-&gt;has_black[0]||p-&gt;has_black[1])return false; &#125; else&#123; p-&gt;all_black=1; if(p-&gt;has_white[0]||p-&gt;has_white[1])return false; &#125; break; &#125; &#125; return 1;&#125;void dfs_num(node* now,int num)&#123; if(now-&gt;all_white)return; if(now-&gt;all_black|| (!now-&gt;has_white[0]&amp;&amp;!now-&gt;has_white[1]))&#123; ++ans; return; &#125; if(now-&gt;next[0])&#123; ip[num]=0; dfs_num(now-&gt;next[0],num+1); &#125; if(now-&gt;next[1])&#123; ip[num]=1; dfs_num(now-&gt;next[1],num+1); &#125;&#125;void dfs(node* now,int num)&#123; if(now-&gt;all_white)return; if(now-&gt;all_black || (!now-&gt;has_white[0]&amp;&amp;!now-&gt;has_white[1]))&#123; subnet_len=num; change_binary(); return; &#125; if(now-&gt;next[0])&#123; ip[num]=0; dfs(now-&gt;next[0],num+1); &#125; if(now-&gt;next[1])&#123; ip[num]=1; dfs(now-&gt;next[1],num+1); &#125;&#125;int main()&#123; root=new node(); int n;cin&gt;&gt;n; while(n--)&#123; scanf(\"%s\",buf); get_binary(); if(!insert())&#123; cout&lt;&lt;\"-1\"&lt;&lt;endl; return 0; &#125; &#125; if(black_num==0)&#123; cout&lt;&lt;\"-1\"&lt;&lt;endl; return 0; &#125; ans=0; dfs_num(root,0); cout&lt;&lt;ans&lt;&lt;endl; dfs(root,0); delete root; return 0;&#125; C. Cloud Computing pending D. Garbage Disposal 签到题一枚，题目大意是给你n天的每天的垃圾量，每个垃圾只能在当天或者第二天扔掉（不能放到第三天），垃圾只能装到包里才能扔，所以给你一个k，表示每个包最多能盛放多少垃圾。问最小需要多少个包。思路：直接贪心即可，每天把当天需要扔的垃圾整除k（装包扔掉），余数（即剩下不够装满一个包）就放到第二天扔。但是要注意垃圾不能存到第三天，所以只要保证当天扔的垃圾大于前一天剩下的即可。ac代码： 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;int main()&#123; long long n,k,last=0,a,ans=0,tmp; cin&gt;&gt;n&gt;&gt;k; while(n--)&#123; cin&gt;&gt;a; a+=last; tmp=a/k; a%=k; if(tmp*k&lt;last)&#123; //如果当天扔的小于昨天剩下的，也要强制扔去 ++tmp; a=0; &#125; ans+=tmp; last=a; &#125; if(last)++ans;//如果最后还剩下，就直接装包扔掉 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; E. Getting Deals Done pending F. Debate 题目大意：给你n（1","categories":[{"name":"平时训练の补题","slug":"平时训练の补题","permalink":"https://yanghaku.github.io/categories/%E5%B9%B3%E6%97%B6%E8%AE%AD%E7%BB%83%E3%81%AE%E8%A1%A5%E9%A2%98/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://yanghaku.github.io/tags/codeforces/"}],"author":"yb"},{"title":"my first blog","slug":"my-first-blog","date":"2019-05-20T00:30:00.000Z","updated":"2019-05-20T00:52:33.000Z","comments":true,"path":"2019/05/20/my-first-blog/","link":"","permalink":"https://yanghaku.github.io/2019/05/20/my-first-blog/","excerpt":"从现在开始，2019.5.20，我将拥有自己的博客了。 对我来说写博客的用处有一下几点：","text":"从现在开始，2019.5.20，我将拥有自己的博客了。 对我来说写博客的用处有一下几点： 每天总结自己做过的题目，加深思考。 为自己写过的代码做备份，之前一直保存在本地，虽然都用文件夹做了分类，但是还是查找不方便，而且有时又懒得保存。 克服自己的懒惰，到了现在，看了自己的github，自己已经有半年没有好好写代码了，不仅仅是手懒，脑子也变得懒了，记得前几天教练还说过：我们已经停止了思考。对，就是停止了思考！现在的程度，是对许多的算法都知道，但是却不能静下心来仔细研究其中的原理和更深层的应用。没有了思考，也就没有了提高，只靠板子是做不了题的！ 所以从此，加油，克服自己的懒惰，才能提高！ 博客名字以后再想吧……","categories":[],"tags":[],"author":"yb"}]}