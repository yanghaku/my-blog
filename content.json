{"meta":{"title":"YangBo","subtitle":"奋斗才能拥有最美丽的人生","description":"一个快废掉的咸鱼罢了","author":"杨博","url":"https://yanghaku.github.io","root":"/"},"pages":[{"title":"about the author of this blog","date":"2019-05-17T05:29:39.000Z","updated":"2019-05-20T16:04:29.000Z","comments":false,"path":"about/index.html","permalink":"https://yanghaku.github.io/about/index.html","excerpt":"","text":"github: yanghaku qq: 1961882079 school: neu"},{"title":"categories","date":"2019-05-20T16:01:56.000Z","updated":"2019-05-20T16:04:45.000Z","comments":false,"path":"categories/index.html","permalink":"https://yanghaku.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-20T16:05:36.000Z","updated":"2019-05-20T16:05:59.000Z","comments":false,"path":"tags/index.html","permalink":"https://yanghaku.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android入门知识","slug":"Android入门知识","date":"2020-01-31T03:19:00.000Z","updated":"2020-02-01T07:33:43.067Z","comments":true,"path":"2020/01/31/Android入门知识/","link":"","permalink":"https://yanghaku.github.io/2020/01/31/Android%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/","excerpt":"想学习Android的第一步，就应该先了解这个平台系统的大体架构，应用的基础知识等，可是我看到很多入门教程第一步就是直接讲环境搭建下jdk什么的，这种太片面了，往后的NDK，安全沙盒什么的看了也很迷茫。所以我自己查找了许多资料并总结了一下。主要有：Android平台架构Android Application 基础知识 安全沙盒与最小权限原则 Android四大组件（重点） 组件启动与组件之间联系 应用的清单文件 应用资源Android SDK 目录结构及作用开发环境搭建","text":"想学习Android的第一步，就应该先了解这个平台系统的大体架构，应用的基础知识等，可是我看到很多入门教程第一步就是直接讲环境搭建下jdk什么的，这种太片面了，往后的NDK，安全沙盒什么的看了也很迷茫。所以我自己查找了许多资料并总结了一下。主要有：Android平台架构Android Application 基础知识 安全沙盒与最小权限原则 Android四大组件（重点） 组件启动与组件之间联系 应用的清单文件 应用资源Android SDK 目录结构及作用开发环境搭建 Android平台架构Android 是一个基于linux内核的开源软件栈，通过软件叠层的方式构建出来的一个操作系统。 平台的架构图（来自官网）： 从下到上分为五层： Linux内核层，HAL硬件抽象层，Library层，Framework层，Application应用层。 Linux内核层Android平台的基础是Linux内核，主要用linux内核执行一些底层的功能，比如线程和底层的内存管理，还有各种设备的驱动，直接和硬件打交道。linux内核的安全性也能保证这Android的安全。 HAL硬件抽象层HAL提供了一个标准的界面，向更高级别的javaAPI框架显示设备的硬件功能。每一个硬件组件都是对应着一个库模块，比如相机模块，蓝牙模块，音频模块等。当javaAPI框架需要访问硬件的时候，Android会为这些硬件加载对应的库模块。其实就是对底层硬件驱动的一种封装，让javaAPI框架层只看到一个标准的接口，而有了硬件的无关性。 Libarary层系统的运行库层，这层主要提供了一些必不可少的运行库。 Android RuntimeAndroid Runtime 包括两部分，一部分是核心运行时库，为javaAPI框架提供java语言中的大部分功能；另一部分是Android运行时。 在Android 5.0 之前，Android运行时都是Dalvik虚拟机。Dalvik虚拟机相当于一个适配于移动设备更优化的一个java虚拟机（JVM）,也是用JIT编译器来解释运行字节码。Dalvik运行的是.dex格式的字节码，是构建的时候将.java源码编译成 .class字节码，然后再压缩优化成.dex的字节码。 这个Dalvik可以与java虚拟机对比理解首先就是Dalvik本身就是一个魔改的java虚拟机，是一种基于寄存器的架构，虽然牺牲了一些平台无关性，但是在代码运行效率方面都比jvm更胜一筹。JVM与Dalvik区别： 运行的字节码不同，指令集架构不同，JVM基于栈，Dalvik基于寄存器 JVM只运行一个实例，所有的应用都运行在同一个虚拟机中，而Dalvik是每一个应用启动都有一个单独的Dalvik虚拟机对应，每一个Dalvik都对应linux里的一个进程。这样就算其中一个应用crash掉了，也不会影响其他的应用。 到了Android 5.0版本之后，这一部分就变成了Android Runtime（ART），ART与Dalvik相比，增加了更多的功能： 不仅有JIT，而且还增加了AOT（预先编译） 优化垃圾回收 更好的调试支持 预先编译是在安装的时候将 .dex 文件编译成机器码（所以安装的时间会变慢很多），运行的时候跳过了解释的阶段，运行效率之类的都显著提高，但是占用的存储空间就大了，也就相当于用空间来换时间。这样使CPU的利用率也降低不少，能够提升电池的续航时间。 总之，Android Runtime安卓运行时就是用来运行apk里的.dex代码的。一个APP对应一个ART实例，并且对应于一个进程。 Native C/C++ Libarary原生C/C++库，通过一些c/c++库为安卓系统提供了一些主要的特性支持。比如OpenGL库提供3D绘图，SQLite库提供数据库支持，WebKit库提供浏览器内核支持…. 这些主要是一些关键的东西（效率至上），所以是用C/C++的库来提供支持。 应用不仅可以调用javaAPI层来访问这里面的模块，而且可以直接调用这些原生库的功能（一般都是在c/c++原生开发的时候）。 NDK: native develop kit 原生开发工具包当c/c++ 原生开发的时候用到的工具包，其实对大部分的应用都没有很大的价值，因为这不可避免地增加了开发的复杂度。一般在以下场景才会用到： 为了非常好的性能。例如游戏，物理模拟这些计算密集型的应用 重复使用自己或者其他开发者已经开发好的c/c++库 在平台之间移植应用 JAVA API Frameworkjava API框架，这层主要是用java写的API，包含了Android OS的整个功能集（也就是说开发的时候可以调用这里面的API就可以实现所有功能）。里面包括着各种系统的服务和四大组件（后面会介绍到）。 System Application 和 Application系统应用可以说是系统内置的应用，这些对于开发者而言，可以像调用java API Framework一样来调用这些System Application。Application就是我们自己写的第三方的应用这种了，是在最上层。 总之，Android APP的开发语言最好还是官方的JAVA/Kotlin，如果有特殊的需要才会用到native c/c++.对于应用开发人员主要研究的就是架构里面的Java API Framework层和System Application层。如果有需要还会用到native c/c++ Library。就像Android运行时和运行库和下层的驱动等，不是研究的重点，在把握全局的同时，也要搞清楚重点。 Android Application 基础知识一个APK文件，包含一个Android应用的所有内容。使用Kotlin，Java，c++编写Android应用，Android SDK会将代码连同数据和资源文件编译成一个APK（Android Package），即带有.apk后缀的归档文件。 安全沙盒与最小权限原则安全沙盒 security sandbox 沙箱(盒)是为执行中的程序提供隔离环境的一种安全机制。它通过严格控制执行的程序锁访问的资源，以确保系统的安全。每一个Android应用都处于各自的安全沙盒里面，它们直接不能互相访问文件等。 Android操作系统首先是多用户的Linux系统，对于每一个应用都是一个不同的用户。 默认情况下，系统会为每一个应用分配一个唯一的用户ID，系统为应用中的所有文件设置权限，使得有权限的用户才能访问对应的文件。 每个进程都拥有一个独立的虚拟机，默认情况下，每个应用都在其自己对应的Linux进程上执行（应用-虚拟机-Linux进程 这三个是一对一的关系） 最小权限原则对于每一个应用，也就是对应的一个唯一的Linux用户，默认情况下只能访问其工作所需要的组件。在此环境中，应用无法访问其未获得权限的系统部分。应用要想访问其他应用的共享数据或者系统服务，有两个途径： 让两个应用共享一个Linux用户（也就是说两个应用的linux userid相同），这样二者可以互相访问。在节省资源的时候，也可以安排拥有相同用户ID的应用在同一个Linux进程内运行，共享同一个虚拟机。 应用可以请求访问设备数据的权限，由用户明确授予这些权限。比如说应用请求获得访问文件，访问相机，访问联系人等等的权限，由用户明确授予即可。 Android四大组件（重点）应用的四大组件： Activity： 拥有用户界面的单一屏幕 Service：在后台运行的组件，没有界面 BroadcastReceiver： （广播接收器）相应系统的广播通知的组件 Content providers：（内容提供程序），管理共享数据，为其他应用提供查询修改接口 ActivityActivity是与用户交互的入口点，拥有单个的屏幕。 官网上的举例：例如电子邮件的应用可能会有三个Activity： 显示新电子邮件列表的Activity 用于撰写电子邮件的Activity 用于阅读电子邮件的Activity这三个紧密协作联系，但是每个Activity都是独立于其他的Activity而存在，其他应用可以启动其中任何一个Activity。 这很像一个web中的一个网页，每一个网页都是独立的，它们一起构成一个网站，其他别的链接也可以打开这个网站里的任何一个网页（当然在Android里面就还会涉及到权限能不能打开的问题）。然后同一时间只能有一个网页显示在屏幕上（独占一个屏幕）。 Activity的生命周期首先是一个标准的图： Activity 包括7个生命周期的流程，分别是： 1onCreate(),onStart(),onResume(),onPause(),onStop(),onDestory(),onRestart(). 其中 onCreate()是生命周期的开始，onDestory()是生命周期的结束 Activity启动： onCreate() -&gt; onStart()（此时不可见） -&gt; onResume -&gt; 处于运行态，可见 Activity被暂时覆盖：onPause() , 当用户取消覆盖的时候 onResume() 恢复 Activity跳转到了新的Activity、Activity进入了后台或者锁屏的时候：running的Activity -&gt; onPause() -&gt; onStop() -&gt; 停滞状态的Activity Activity重新回到前台或者解锁的时候： 停滞状态的Activity -&gt; onRestart() -&gt; onStart() -&gt; onResume() -&gt; Activity重新running Activity在后台且内存不足的时候：系统会杀死这个后台状态的Activity（此时这个Activity的引用虽然在任务栈中，但是这个时候引用指向的对象已经是null）。若想再回到running，就需要重新初始化生命周期: onCreate() -&gt; onStart() -&gt; onResume() Activity退出: onPause() -&gt; onStop() -&gt; onDestory() (上面的方法都是对应事件的回调函数，选择重写的方法而不能主动调用。如果想主动退出Activity，应该调用finish())。 Activity的四种启动模式因为我们的APP一般都是由多个Activity构成的，而在Android给我们提供了任务（Task）的概念，就是将多个相关的Activity收集起来，进行Activity的跳转与返回。实现Android就是通过任务栈来管理这些Activity的。任务栈：任务栈是一种后进先出的结构。切换到新的Activity，就会被压入栈中成为栈顶。位于栈顶的Activity处于running状态。当back按钮按下的时候，栈顶的Activity会出栈并且调用onDestory()结束生命周期，紧随其后Activity的成为栈顶。当栈内没有Activity那么系统就会回收这个栈，每个APP默认只有一个栈，以这个APP的包名来命名。 四种启动模式： standard标准模式: 默认的模式，新的Activity会默认压入栈中。 singleTop栈顶复用模式：如果新的Activity在任务栈的栈顶（也就是跟栈顶的相同）那么就不会重新创建。如果不在任务栈的栈顶，就跟standard模式相同。 singleTask栈内复用模式：如果新的Activity在任务栈的栈内，那么新的Activity就不会创建，而是将原本栈内的Activity调到栈顶（这个Activity之上的所以Activity都会被清理销毁）。 singleInstance单例模式：这个要求更严格，这种模式的Activity只能单独的位于一个任务栈里面，是一个加强版的singleTask。任务栈里面只能有这一个Activity。 Service服务是Android中实现程序后台运行的解决方案，非常适合去执行那些不需要和用户交互而且还要求长时间运行的任务（没有界面）。比如下载，播放音乐等等。 Service的生命周期先看图：首先service的声明中，onCreate()只会回调一次来创建,onDestory()只会在关闭的方法回调一次。启动service的方法有三种： StartService()启动service BindService() 启动service start之后再bind 这几者的区别：StartService只是启动这个service，启动它的组件（比如Activity）和这个Service没有关联。service的关闭只能是自己执行完某些任务了之后执行stopSelf或者其他组件调用它的stopService才能终止。BindService方法启动的Service，其他组件可以通过回调获取Service的代理对象和Service交互，而且两方进行绑定，当启动的组件销毁的时候，Service会自动进行unBind操作解绑。当发现所有的绑定都进行了unBind的时候，Service会销毁。先start然后另一个组件进行bind这个已经启动的Service的时候，系统仅仅是进行了绑定而不会把生命周期与另一个组件绑定。也就是解绑了之后Service还是属于start启动的service。 BroadcastReceiver广播能够广泛的运用在应用程序之间传递事件信息的机制。借助广播接收器，系统能够在常规的用户流之外向应用传递事件，从而允许应用响应系统范围内的广播通知。广播接收器可以对许多外部事件进行响应，比如当电话呼入，手机屏幕关闭等事件，系统会发出广播，对应的注册的广播接收器会收到这些事件消息对应地处理。广播接收器虽然没有界面，但是可以创造状态栏的通知。比如wifi连接-&gt; 系统广播事件-&gt;对应的广播接收器收到后创建通知：网络连接恢复。 广播接收器有两种注册方法：静态注册和动态注册 静态注册： 在AndroidManifest.xml（应用清单文件，下文会仔细解释）里声明，当APP首次启动的时候就注册到系统中。 动态注册： 在某个组件（一般是Activity）运行的时候注册广播接收器。区别：静态注册是一直在监听对应的消息，耗电耗内存，当APP退出之后也能收到对应的消息进行处理。 动态注册是在代码中动态的注册，当组件退出之后也没法接受广播了（注意要在组件结束前移除广播接收器，否则会导致内存泄漏）。 Content providers内容提供者提供内容的共享。可以将文件，数据库，网络上的可持久化的数据提供给其他应用修改查询。一般有两个场景： 自己的应用需要访问别的应用的数据，比如访问手机联系人，短信等，想对这些数据进行读取或修改，就要用到这些应用的ContentProvider。 自己的应用需要给别的应用共享信息，也要用到ContentProvider，而且可以选择性的共享信息，避免了关键隐私信息泄露等。 组件启动与组件之间联系Android系统的独特之处在于，任何应用都可以启动其他应用的组件。 比如一个应用想让用户使用设备相机拍摄照片，那可以使用系统的照片应用中对应的Activity即可，当拍摄之后会返回到原先的应用，对用户来说这相机就如同应用的一部分。当系统启动一个应用的组件时候，就会启动这个应用对应的进程（如果没有启动的话）。这个应用和相机还是属于两个进程。所以说Android应用没有单个的入口点（main()函数），每一个组件都可以是应用的入口。 因为安全沙箱的存在，不能直接启动另一个应用的组件，而是需要系统作为中间人。这些组件之间启动或者访问，就需要传递消息，这个消息就是 Intent（意图）。 Intent 是启动组件，是组件直接联系的桥梁。四种组件之中，Activity，Service，BroadCastReceiver 这三个组件都是通过Intent启动。（ContentProvider会在ContentResolver请求目标的时候启动，与其他不一样）。对于启动Activity和Service，Intent会定义要执行的操作，并且可以指定待操作的数据等信息。对于BroadcastReceiver，Intent只会定义待广播的通知。 Intent对象大致包括7个属性：Action（动作），Data（数据），Category（类别），Type（数据类型），Component（组件），Extra（扩展信息），Flag（标志位）。 Intent分为显式Intent和隐式Intent。 显式Intent： 直接通过组件名来启动某个组件，每次启动的组件只有一个。 隐式Intent： 不指定组件名，而是指定Intent的Action，Data等（只描述意图），当我们启动的时候，会匹配出相关的满足要求的组件，如果不止一个，就会让用户选择使用哪个来处理Intent。一个最熟悉的场景就是隐式Intent： 应用的清单文件在Android系统启动应用之前，系统必须通过读取应用的清单文件（AndroidMainifest.xml）确认组件的存在，应用中所有用到的组件(除了动态注册的广播接收器) 都需要在这个文件中声明。这个文件必须位于应用目录的根目录中。除了声明应用的组件之外，清单文件还有许多其他的作用，比如： 确定应用需要的任何用户权限，比如访问联系人，访问文件等 根据应用使用的API，声明所需的最低API级别 声明需要的硬件软件功能，比如相机等 主要的三个功能： 声明组件代码里的Activity就是声明的一个组件 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest ... &gt; &lt;application android:icon=\"@drawable/app_icon.png\" ... &gt; &lt;activity android:name=\"com.example.project.ExampleActivity\" android:label=\"@string/example_label\" ... &gt; &lt;/activity&gt; ... &lt;/application&gt;&lt;/manifest&gt; 声明组件的功能这个就是声明了一个执行动作为SEND发送的一个组件 123456789101112&lt;manifest ... &gt; ... &lt;application ... &gt; &lt;activity android:name=\"com.example.project.ComposeEmailActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.SEND\" /&gt; &lt;data android:type=\"*/*\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 声明应用要求 123456&lt;manifest ... &gt; &lt;uses-feature android:name=\"android.hardware.camera.any\" android:required=\"true\" /&gt; &lt;uses-sdk android:minSdkVersion=\"7\" android:targetSdkVersion=\"19\" /&gt; ...&lt;/manifest&gt; 应用资源Android应用不仅仅是代码，还需要与源代码分离的静态资源，比如图像，音频文件还有xml文件定义的界面动画等。所有的资源都在 /res 的文件夹内。 Android SDK 目录结构及作用1234567891011121314android-sdk&#x2F; add-ones&#x2F; -&gt; 一些附加的库，第三方公司的附加功能，比如GoogleMaps等 build-tools&#x2F; -&gt; 构建项目的时候用到的工具，还包括一些编译工具等 28.0.3&#x2F; 29.0.3&#x2F; docs&#x2F; -&gt; 离线的开发者文档（可选） platforms&#x2F; -&gt; sdk里面最重要的文件，每个文件夹都含有各个版本的sdk android-28&#x2F; -&gt; API级别28的sdk版本 android-29&#x2F; platforms-tool&#x2F; -&gt; 各版本sdk通用的工具，比如abd.exe,sqlite3.exe等 skins&#x2F; -&gt; 安卓模拟器的皮肤 system-images&#x2F; -&gt; 创建安卓模拟器的时候使用的系统镜像 android-28&#x2F; tools&#x2F; -&gt; 通用的Android开发、调试的工具 还有两个很重要的工具： SDK管理器 和 安卓模拟器管理器。（可以直接用IDE上带的工具来代替） 开发环境搭建操作系统：win10IDE：Android Studio （用起来跟idea一个感觉，非常棒！比VS强太多了）（直接官网下载安装即可） 安装之后主要是设置SDK和模拟器。（我之前用VS下过一个sdk，Android Studio直接识别出来本地的了！） 设置好之后就新建工程，然后新建一个空白的工程，一路next，IDE会自动生成一个空白项目。项目结构如下： 根目录里的清单文件 AndroidMainifest.xmljava/ 下的java代码（只有一个组件MainActivity）res/ 里是应用的各种资源，包括布局，图片等等。res/layout 里的activity_main.xml 就是MainActivity这个Activity对应的布局文件。 配置好模拟器设备之后，直接点击run运行即可完成 Hello World! 参考链接 Android开发者平台（官网有最新文档） Android基础入门教程-菜鸟教程 简单理解Android Dalvik Android Runtime (ART) 和 Dalvik NDK开发从放弃到入门 安卓基础知识-简书 安卓四大组件-简书 Android四大组件：BroadcastReceiver史上最全面解析-简书","categories":[{"name":"Android学习","slug":"Android学习","permalink":"https://yanghaku.github.io/categories/Android%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yanghaku.github.io/tags/Android/"}]},{"title":"Xamarin学习1 -- 概念篇","slug":"Xamarin学习1概念篇","date":"2020-01-30T08:46:00.000Z","updated":"2020-01-31T03:19:59.308Z","comments":true,"path":"2020/01/30/Xamarin学习1概念篇/","link":"","permalink":"https://yanghaku.github.io/2020/01/30/Xamarin%E5%AD%A6%E4%B9%A01%E6%A6%82%E5%BF%B5%E7%AF%87/","excerpt":"主要介绍了 Xamarin 中 Xamarin.forms , Xamarin.Android, Xamarin.iOS 的区别和联系，并且搭建环境和创建第一个 Xamarin.forms 应用并运行调试。","text":"主要介绍了 Xamarin 中 Xamarin.forms , Xamarin.Android, Xamarin.iOS 的区别和联系，并且搭建环境和创建第一个 Xamarin.forms 应用并运行调试。 XamarinXamarin 是一个开源平台，用于通过 .NET 构建适用于 IOS，Android 和 Windows 的新式应用程序。是一个抽象层，可用于管理共享代码与基础平台代码的通信。使开发人员能够跨平台共享应用程序，允许开发人员以一种语言编写所有的业务逻辑，但是在每个平台上各自实现外观等。 说白了就是共享底层逻辑的 C# 的代码，并且创建各自的UI, 使得一个工程开发能够多个平台使用。 然后就是 Xamarin 的结构： Xamarin.AndroidXamarin.Android 是将 C# 编译为中间语言，然后在程序运行的时候，通过即时编译（JIT）编译成本机程序集（类似于java虚拟机的那种）。 Xamarin.iOSXamarin.iOS 是将应用程序完全编译成本机的ARM程序集代码（完全的静态编译）。 Xamarin.Android 和 Xamarin.iOS 其实就是两个单独的工程，前者是专门对于Android开发的，后者是专门对于iOS开发的工程。但是Xamarin不是跨平台的吗？ 这个时候就用到了 Xamarin.Forms 了！ Xamarin.FormsXamarin.Forms 是一个开源的 UI 框架，允许开发者写一种UI布局与设计，然后根据不同的平台渲染成不同的UI控件(实现了跨平台的UI开发) 上图中的 Xamarin.Forms Platform Renderer 就是做这种事情的。 就像官网文档说的： Who Xamarin.Forms is forXamarin.Forms is for developers with the following goals: Share UI layout and design across platforms. Share code, test and business logic across platforms. Write cross-platform apps in C# with Visual Studio. 以上的关系总结 Xamarin.Android 和 Xamarin.iOS (其实还有Xamarin.Mac , Xamarin.UWP，Xamarin.tvOS 等) 这些都是Xamarin里的具体的工程， 专门对应于具体的平台里的，可以单独开发。 而Xamarin.Forms 是用于跨平台的，可以实现同时开发Android和iOS和UWP 等，将一个共享的里的分别渲染到具体的工程里去，实现大部分的UI和逻辑代码共享。 比如在VS2019 里面创建一个Xamarin项目的时候，可以看到非常多的选项： 第一个Xamarin.Forms 就是一个跨平台的方案，当在Xamarin forms创建的时候勾选这Android和iOS的时候(因为没有装UWP的开发环境，所以只选了这两个)，项目的结构就会如下： 也就是说， Xamarin.Forms 包含了其他的工程，而像 Xamarin.Android 这种既可以是独立开发的工程，也可以当做Xamarin.Forms 里的一部分通过Xamarin.Forms 一起开发。 所以说清楚了这些之后，官网上的那些文档也就不觉得混乱了， 想学哪一块就可以针对性地学习了。 环境搭建操作系统 ： win10 IDE： visual Studio 2019 （刚下载的） 如果只需要Android和iOS开发的话，只要在vs installer 上选择移动开发的负载下载即可 安卓需要java SDK 8， Android SDK 和安卓模拟器 这三个东西vs都给自动装好了. 其中jdk8自动被安装才了“C:\\Program Files\\Android\\jdk\\microsoft_dist_openjdk_1.8.0.25”. Android SDK 装在了 “C:\\Program Files (x86)\\Android\\android-sdk” （当然，可以自己设置） 然后安卓的模拟器就是自动保存在了自己用户文件夹下的 “.Android” 里面（这个需要自己安装设备，具体在下文） 安卓模拟器有硬件加速，运行之前需要在 “控制面板”-&gt; “程序与功能” -&gt; 左栏 “启用或关闭windows功能” -&gt; “windows虚拟机程序监控平台” 勾选上， 否则每次运行之前都会有一个警告。 第一个 Xamarin.Forms 工程打开vs， 新建项目，在框里搜索 Xamarin， 点击选中 Xamarin.forms, 然后设置项目名称，目录等， 然后点创建。 之后选择空白的模版， 平台勾选Android和iOS （有环境的也可以勾选UWP试试），然后就创建完成。 项目结构： 其中XamarinApp1.Android 就是对应的生成安卓的工程， XamarinApp1.iOS 就是对应的iOS的工程。 在MainPage.xaml 中编辑，把 “Welcome …” 换成 “hello World” （程序猿开发第一步嘛），然后就是运行了。 Xamarin.Android 的运行调试运行安卓之前需要安装安卓的模拟器，VS的安卓工具里有两个挺重要的工具：Android SDK管理器和 Android 设备管理器。 点击工具 -&gt; Android -&gt; Android SDK 管理器 我这上面是下载的默认的 安卓SDK9; 设置的图片： Android SDK 有了之后，就安装对应的设备就行了。点击 工具 -&gt; Android -&gt; Android Device Manager 点击新建（新建一个安卓虚拟设备） 操作系统要选择已经装好的sdk对应的版本， 处理器选择 x86（官网说x86比x86_64实际会快，而且可以硬件加速） ，其他可以不用多设置（以后可以再改嘛，先能运行再说）， 点击创建即可。 创建完成后，在上面的工具栏里，选择需要运行的Android和对应的设备，点击运行，即可完成 运行截图： 到此第一步完成，Android上部署成功！ Xamarin.iOS 运行调试Xamarin.iOS 调试需要iOS真机， 如果是模拟器也需要MAC系统才行（贫穷限制了开发人员的学习）。 找了一圈，发现了一个方案： windows装 MAC虚拟机，然后再MAC上装模拟器和VS，详情 可以实现但是太麻烦，就不瞎折腾了。 这个跨平台是挺棒，但是不代表着学习了Xamarin就会了Android和iOS的开发， 每个平台的特性都需要了解的。iOS 系统的很多特性都不了解是写不出来高质量的程序的，甚至还得要求开发者掌握一些 Object-C 的语法 。所以说没有接触使用过iOS的我果断放弃啦.. 所以对于我个人来说，往后的学习可能只是限制在Xamarin.Android， 而不是上面的跨平台特性（没有其他平台的需求）。 如果只学习 Android开发，用java入门更好，但是多学点新的东西不也很刺激么hh 以上仅仅是我个人的理解，不一定是完全正确的！！ 如果有错误请评论指出，谢谢！ 参考链接 官网Xamarin文档 Xamarin.Form与Xamarin.Android或Xamarin.IOS的区别简述 写给 iOS 程序员的 Xamarin 入门教程","categories":[{"name":".NET学习","slug":"NET学习","permalink":"https://yanghaku.github.io/categories/NET%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yanghaku.github.io/tags/Android/"},{"name":".NET","slug":"NET","permalink":"https://yanghaku.github.io/tags/NET/"},{"name":"Xamarin","slug":"Xamarin","permalink":"https://yanghaku.github.io/tags/Xamarin/"},{"name":"iOS","slug":"iOS","permalink":"https://yanghaku.github.io/tags/iOS/"}]},{"title":".NET初学概览","slug":"NET概览","date":"2020-01-29T08:46:00.000Z","updated":"2020-01-31T03:26:46.239Z","comments":true,"path":"2020/01/29/NET概览/","link":"","permalink":"https://yanghaku.github.io/2020/01/29/NET%E6%A6%82%E8%A7%88/","excerpt":"主要是对 .NET Core, .NET Standard, .NET framework 和 Xamarin 的介绍和区分 并且介绍一下其中的ASP.NET, UWP， XAMARIN 等 然后就是 .NET 的未来： .NET 5 （2019年5月宣布的下一代的版本），将把前面这些运行时全部合为一体 以前刚开始听说 .NET 的时候，我只知道 .NET framework , 然后昨天看了一眼官网的 .NET 入门学习的时候吗，又看到了 .NET Core, 然后各种名词接踵而来，有点懵，所以就总结了一下下。","text":"主要是对 .NET Core, .NET Standard, .NET framework 和 Xamarin 的介绍和区分 并且介绍一下其中的ASP.NET, UWP， XAMARIN 等 然后就是 .NET 的未来： .NET 5 （2019年5月宣布的下一代的版本），将把前面这些运行时全部合为一体 以前刚开始听说 .NET 的时候，我只知道 .NET framework , 然后昨天看了一眼官网的 .NET 入门学习的时候吗，又看到了 .NET Core, 然后各种名词接踵而来，有点懵，所以就总结了一下下。 首先就是当下的框架图： .NET广义的 .NET 是一个通用的开发平台，能够跨语言，跨平台 ，能够支持跨多个平台的方案 .NET 开发可以实现包括 .NET Framework、.NET Core 和 Mono。 .NET 的所有实现都有一个名为 .NET Standard 的通用 API 规范。 .NET 与 java 对比理解： .NET 与 java有很多相似的地方，两者都是即时编译语言（JIT）， 项目编译生成的文件不是具体的机器码，而是中间语言。 在java里面叫做字节码（bytecode）， 而在 .NET里面叫做中间语言（Common Intermediate Language，简称 IL），java官方运行环境是java的虚拟机JRE（Java Runtime Environment）， 而在 .NET 官方运行环境叫做公共语言运行时（Common Language Runtime， 简称CLR） 这是 .NET 跨语言，跨平台的基础 跨语言： c#， f#， VB.NET 这些面向 .NET 的都可以 跨平台： 开发 Windows，Linux，macOS，iOS，Android，tvOS，watchOS 和 WebAssembly .NET framework传统的 .NET framework 是以一种采用CLR 为基础，支持多种语言（c#，f#，VB.NET, c++，Python等）的开发。 这也是我们用到的最多最熟悉的 .NET , 这个缺点就是不能跨平台，只能在windows上用。一般就是用来做桌面应用程序和ASP.NET的. .NET Core主要是针对windows，linux，macOS，服务器和控制台应用程序的跨平台 .NET 实现 它支持四种应用程序：控制台，ASP.NET Core, 云 和通用windows平台( UWP ) 需要注意的是: 尽管微软把 .NET Core作为.NET未来的发展方向，但 .NET Core和 .NET Framework 仍然是两个独立的产品。.NET Framework也会继续更新和维护。 .NET Core 不再是windows 专门的，在其他平台也可以用。 就是为了跨平台而做的，不是windows的一个组件了。 .NET Standard.NET Standard 是一组由.NET 实现的基本的API集。 是一个进一步实现跨平台跨设备的代码共享。其实是未来 .NET的核心，一切基于它来实现代码共享。 .NET Standard 和 .NET 之间 相当于html 规范和 浏览器之间的关系，后者是前者的实现。 Xamarin 与 MonoMono是 .NET 开源之前的一个跨平台的方案，是由Xamarin公司主持的开源项目，可以运行于Linux等其他平台 （于2016年被微软收购）。相当于实现了各个平台上的 .NET 的公共语言运行时（CLR）。 现在主要运用在移动设备，许多著名的游戏引擎比如Unity3D也包含着这个技术。 对于IOS和Android 应用程序，Xamarin 将 .NET 技术代入里面， 成为唯一一个能够提供跨iOS，Android和windowsPhone 的单一语言平台。 ASP.NET 和 ASP.NET Core这两个只是以上框架里的一个小组件，用于开发Web应用程序。 然后两个的区别就是ASP.NET 是 .NET framework 里的组件， 只有windows版本的API 而ASP.NET Core 是 .NET Core 的组件，是对于跨平台准备的，是 ASP.NET 的跨平台版本。 所以说以上这么多的名词，都是因为不断进化产生的，从只有一个 .NET framework 只支持windows平台，到后来的跨平台的方案，都在慢慢发展来的。 三个框架与应用总结所以再回顾一下上面的那个图片: 现在主要的三个框架实现 .NET Framework （最新到4.8版本）主要是对windows平台的 .NET Core （最新到3.1版本）可以跨平台，主要是一些控制台设备，如linux，windows，macOS等 XAMARIN 主要是针对移动设备的，比如Android，iOS等 官网文档上说的： There are various implementations of .NET. Each implementation allows .NET code to execute in different places—Linux, macOS, Windows, iOS, Android, and many more. .NET Framework is the original implementation of .NET. It supports running websites, services, desktop apps, and more on Windows. .NET Core is a cross-platform implementation for running websites, services, and console apps on Windows, Linux, and macOS. .NET Core is open source on GitHub. Xamarin/Mono is a .NET implementation for running apps on all the major mobile operating systems, including iOS and Android. .NET Standard is a formal specification of the APIs that are common across .NET implementations. This allows the same code and libraries to run on different implementations. .NET 5 未来的展望现在这么多的框架什么的，到了 .NET5 将会融为一体。 .NET 5 将会融合 .NET Framework , .NET Core, Mono, Xamarin 等优点构建出一个统一的 .NET 平台，开发人员可以使用 C#， VB.NET, F# 等语言，使用相同的API 开发针对任何系统，任何架构，任何形态的应用程序，并且代码和库均可通过 .NET Standard 共享 。 也就是说，到了那个时候开发出一个应用程序，就可以全平台通吃，只要有一个 .NET, 就能一次开发出适用于Windows，Linux，macOS，iOS，Android，tvOS，watchOS 和 WebAssembly 等所有平台的应用程序了。 希望早日到来，让俺们这些开发人员感受感受叭。 2019年5月微软宣布的.NET5， 将会在 2020年11月发布 参考链接： .NET:持续进化的统一开发平台 .NET Core和.NET Standard有什么不同 (翻译)正式宣布 .NET 5","categories":[{"name":".NET学习","slug":"NET学习","permalink":"https://yanghaku.github.io/categories/NET%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":".NET","slug":"NET","permalink":"https://yanghaku.github.io/tags/NET/"},{"name":".NET Core","slug":"NET-Core","permalink":"https://yanghaku.github.io/tags/NET-Core/"},{"name":"Xamarin","slug":"Xamarin","permalink":"https://yanghaku.github.io/tags/Xamarin/"}]},{"title":"失踪半年人口回归","slug":"失踪半年人口回归","date":"2020-01-29T03:00:00.000Z","updated":"2020-01-29T13:29:00.195Z","comments":true,"path":"2020/01/29/失踪半年人口回归/","link":"","permalink":"https://yanghaku.github.io/2020/01/29/%E5%A4%B1%E8%B8%AA%E5%8D%8A%E5%B9%B4%E4%BA%BA%E5%8F%A3%E5%9B%9E%E5%BD%92/","excerpt":"今天是大年初五，2010.1.29， 在家连续玩了四天了，要开始继续学习了呀。 自从电脑从linux 换成 windows ，就没有再重新配置hexo的环境（说白了太懒了），昨天折腾了一整天，把电脑里的文件整理、清理，升级或者卸载不用的软件，外加更新几个linux的虚拟机，整整折腾了一整天。昨天又下了nodejs，重新搞了一下hexo，继续写吧，每天学学学，总得留下什么吧。 还是没有养成写点东西的习惯，许多东西学得快，忘得也快。还有一些算法或者什么思想啦，只在脑中形成一些概念而已，没有经过系统的思考，慢慢也会忘掉的。记笔记尤其是写markdown，总能梳理出一个清晰的思路来。就比如过年之前花费了十几天","text":"今天是大年初五，2010.1.29， 在家连续玩了四天了，要开始继续学习了呀。 自从电脑从linux 换成 windows ，就没有再重新配置hexo的环境（说白了太懒了），昨天折腾了一整天，把电脑里的文件整理、清理，升级或者卸载不用的软件，外加更新几个linux的虚拟机，整整折腾了一整天。昨天又下了nodejs，重新搞了一下hexo，继续写吧，每天学学学，总得留下什么吧。 还是没有养成写点东西的习惯，许多东西学得快，忘得也快。还有一些算法或者什么思想啦，只在脑中形成一些概念而已，没有经过系统的思考，慢慢也会忘掉的。记笔记尤其是写markdown，总能梳理出一个清晰的思路来。就比如过年之前花费了十几天学习了java的SSM框架，虽然学了写了好多，但是现在就感觉全部忘掉了····· 也许是记忆力也出了点小问题叭。不管怎样，我还是要记下来，每天都记一记。 首先还是要好好反思自己，作为一名现役的ACM队员，19年下半年做的题量还不如我大一的一个月做的多，这是非常不正常的，银川回来之后，原想努把力去上海冲个金，结果才拿了铜，ccpc-final和ec-final相继打铁。想想也是太丢人了，我的状态不对呀！ 及时改变自己吧，生活还是可以回到正轨上来的。下个赛季，大四再打一个赛季，把在赛场上丢的脸捡回来，证明自己。 确实不应该，放弃了最好的一个学期去做了自己都知道没有结果的事情。冷静下来一想，是自己没有把握好度，失去了理智像飞蛾扑火般，不管怎样，都是一段很好的回忆叭。 自己也是在不断成长的呢，明白了许多的道理，看到了自己以前没有看到的方面，知道了自己的不足，也算是一种提高，一种阅历吧。 总之，悟已往之不谏，知来者之可追！！ 1000题的小目标还没开始做呢，不要老想着明天啦，明日复明日，明日何其多嘛，现在就开始！ 我的数论模版还没整理完呢，希望能在开学前整理完~~ java的SSM框架的工程才写了一半，希望也能抽空写完~~（idea intellij 太好用了，吹爆！jb-mono字体也很棒哦） 昨天晚上突然看了一眼 .net , 学着用c#写了一个hello world，感觉还挺有意思，希望能有空学一学~~ 当然 linux内核的源码也想学学，这本书放桌面上几个月了还没看…… 还是挺多东西学习的，继续加油叭，奥利给！！ 奥利给！！","categories":[{"name":"日常碎碎念","slug":"日常碎碎念","permalink":"https://yanghaku.github.io/categories/%E6%97%A5%E5%B8%B8%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[],"author":"yb"},{"title":"2019东北地区四省赛","slug":"2019东北地区四省赛","date":"2019-05-22T06:00:00.000Z","updated":"2019-06-04T13:31:37.000Z","comments":true,"path":"2019/05/22/2019东北地区四省赛/","link":"","permalink":"https://yanghaku.github.io/2019/05/22/2019%E4%B8%9C%E5%8C%97%E5%9C%B0%E5%8C%BA%E5%9B%9B%E7%9C%81%E8%B5%9B/","excerpt":"题目pdf链接 提交链接(codeforces)","text":"题目pdf链接 提交链接(codeforces) 在现场(我)写崩了C题，虽然最后救回来了（队友带飞），但是还差一点，差一题才到金 概览： A. Apple Business B. Balanced Diet C. Line-line Intersection D. Master of Data Structure E. Minimum Spanning Tree F. Mini-game Before Contest G. Radar Scanner H. Skyscraper I. Temperature Survey J. Time Limit A. Apple Business pending（暂时不会） B. Balanced Diet 题意：给你n个糖果，每个糖果有价值$a_i$,属于种类$b_i$,让选择一些糖果，使得 (总价值/选择种类最大的个数) 尽量大，第j种糖果如果选择，选择的个数就应该大于等于$l_j$,(1","categories":[{"name":"现场赛の补题","slug":"现场赛の补题","permalink":"https://yanghaku.github.io/categories/%E7%8E%B0%E5%9C%BA%E8%B5%9B%E3%81%AE%E8%A1%A5%E9%A2%98/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://yanghaku.github.io/tags/codeforces/"}],"author":"yb"},{"title":"2018-2019 ICPC, NEERC, Southern Subregional Contest ","slug":"2018-2019-ICPC-NEERC-Southern-Subregional-Contest","date":"2019-05-20T00:54:00.000Z","updated":"2020-01-29T02:25:45.829Z","comments":true,"path":"2019/05/20/2018-2019-ICPC-NEERC-Southern-Subregional-Contest/","link":"","permalink":"https://yanghaku.github.io/2019/05/20/2018-2019-ICPC-NEERC-Southern-Subregional-Contest/","excerpt":"这套题目难度适中吧，只不过我们队还没做到自己的最好，自闭了好几个小时的题目竟然是水题 题目pdf链接 codeforce提交链接","text":"这套题目难度适中吧，只不过我们队还没做到自己的最好，自闭了好几个小时的题目竟然是水题 题目pdf链接 codeforce提交链接 概览： A. Find a Number B. Berkomnadzor C. Cloud Computing D. Garbage Disposal E. Getting Deals Done F. Debate G. Monsters and Potions H. BerOS File Suggestion I. Privatization of Roads in Berland J. Streets and Avenues in Berhattan K. Video Posts L. Odd Federalization M. Algoland and Berland A. Find a Number 题目大意： 给你一个d(1&lt;=d&lt;=500),和s(1&lt;=s&lt;=5000)，找到一个最小的整数n使得n是d的倍数并且各数位之和为s，不存在就输出-1。 这个题自闭了四个小时还没做出来，其实就是一个简单的bfs！！ 思路：记 dp[x][y] 为余数为x，各数位之和为y的数的最小值，因为数位太大，所以可以用一个string保存。状态转移方程是： dp[(x10+k)%d][y+k]=dp[x][y]+string(k) (0&lt;=k&lt;=9) //其中＋为字符串的连接操作。所以只要找到dp[0][s]即可，初始的状态为dp[k%d][k] (1&lt;=k&lt;=9) (即只有一位的时候） 直接用记忆化的BFS搜索即可，而且这样可以保证每次第一次访问到的状态都是最小的，因为加入队列的顺序是*从小到大**的。（有一个与此题非常相似的题，就是因为这个从小到大的特性才能AC–&gt;题目链接：Enigma）。 ac代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;int d,S;//string str[501][5001];bool vis[501][5001];struct T&#123; int x,y; string s; T(int xx,int yy,string ss):x(xx),y(yy),s(ss)&#123;&#125;&#125;;queue&lt;T&gt;q;int solve()&#123; while(!q.empty())q.pop(); for(int i=1;i&lt;10;++i)&#123; q.emplace(i%d,i,string(1,char(i+'0'))); vis[i%d][i]=1; &#125; while(!q.empty())&#123; int x=q.front().x; int y=q.front().y; string s=q.front().s; q.pop(); if(x==0&amp;&amp;y==S)&#123; cout&lt;&lt;s&lt;&lt;endl; return 0; &#125; for(int i=0;i&lt;10;++i)&#123; if(y+i&gt;S)continue; int id=(x*10+i)%d; if(vis[id][y+i]==0)&#123; vis[id][y+i]=1; q.emplace(id,y+i,s+char(i+'0')); &#125; &#125; &#125; return 1;&#125;int main()&#123; cin&gt;&gt;d&gt;&gt;S; if(solve())cout&lt;&lt;\"-1\"&lt;&lt;endl; return 0;&#125; 优化： 上面的代码跑了1200多ms，虽说没有超时，但是还是完全可以优化的。考虑到每次的状态都需要一个string保存，每次状态转移都是前一个的string复制后再添上一个字符（而其中的复制和动态内存的分配与释放消耗的时间非常多），所以说这个地方可以有很大的优化。考虑到每次状态转移都是只添加一个字符，而其他字符就可以直接用上一个状态的就行，所以可以做成一个链表，每一个状态都保存它上一个状态的地址（两个坐标），就能生成最后的字符串，这样可以节省所有的字符串复制的时间。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;int d,S;//string str[501][5001];bool vis[501][5001];int lastx[501][5001],lasty[501][5001];char ch[501][5001];struct T&#123; int x,y; T(int xx,int yy):x(xx),y(yy)&#123;&#125;&#125;;queue&lt;T&gt;q;void getString(int x,int y)&#123; string s=\"\"; int tmp; while(x!=-1)&#123; s=s+ch[x][y]; tmp=lastx[x][y]; y=lasty[x][y]; x=tmp; &#125; reverse(s.begin(),s.end()); cout&lt;&lt;s&lt;&lt;endl;&#125;int solve()&#123; while(!q.empty())q.pop(); for(int i=1;i&lt;10;++i)&#123; q.emplace(i%d,i); vis[i%d][i]=1; lastx[i%d][i]=-1; lasty[i%d][i]=-1; ch[i%d][i]=i+'0'; &#125; while(!q.empty())&#123; int x=q.front().x; int y=q.front().y; q.pop(); if(x==0&amp;&amp;y==S)&#123; getString(x,y); return 0; &#125; for(int i=0;i&lt;10;++i)&#123; if(y+i&gt;S)continue; int id=(x*10+i)%d; if(vis[id][y+i]==0)&#123; vis[id][y+i]=1; q.emplace(id,y+i); ch[id][y+i]=i+'0'; lastx[id][y+i]=x; lasty[id][y+i]=y; &#125; &#125; &#125; return 1;&#125;int main()&#123; cin&gt;&gt;d&gt;&gt;S; if(solve())cout&lt;&lt;\"-1\"&lt;&lt;endl; return 0;&#125; 两次运行时间对比：(可以发现少了将近1s） B. Berkomnadzor (mid) 字典树大模拟，题目大意：给你n个ip地址(也可能是一个划分的子网）都是使用点分十进制表示法，这n个ip有的属于白名单，有的属于黑名单，然后就是让你把黑名单合并，要求在白名单中的不能属于黑名单，不在白名单中的ip也可以进入黑名单，让你合并后的黑名单个数尽量少。（如果某个ip既在黑名单又在白名单，那么就输出-1。 思路：首先写好点分十进制和二进制ip的相互转化函数，字典树里面只包括0,1字符即可，每个节点要维护当前ip地址(或者子网)是否属于黑名单或者白名单，当前节点之后的子网有没有属于白名单的，有没有属于黑名单的即可。检查冲突：如果下面的所有子网地址都属于一个确定的黑(白)名单，那么就可以判断是否与当前正在插入的ip有冲突，如果到达当前ip的子网掩码长度，就可以判断下面的子网中有没有与此冲突。 注意有子网掩码为0的情况，也就是包括所有的ip的情况。 ac代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char buf[30];int ip[100],white;int len,subnet_len,ans,black_num=0;struct node&#123; node* next[2]; bool has_white[2]; bool has_black[2]; bool all_white; bool all_black; node()&#123; memset(next,0,sizeof(next)); memset(has_white,0,sizeof(has_white)); memset(has_black,0,sizeof(has_black)); all_white=all_black=0; &#125; ~node()&#123; if(next[0])delete next[0]; if(next[1])delete next[1]; &#125;&#125;*root;void get_binary()&#123;//将点分十进制变为二进制 if(buf[0]=='+')white=1; else white=0,++black_num; len=strlen(buf); int tot=0; subnet_len=32; for(int i=1;i&lt;len;++i)&#123; int x=0; while(i&lt;len&amp;&amp;buf[i]&gt;='0'&amp;&amp;buf[i]&lt;='9')&#123; x=x*10+buf[i]-'0'; ++i; &#125; if(tot==32)&#123; subnet_len=x; break; &#125; for(int k=0;k&lt;8;++k)&#123; if((x&gt;&gt;(7-k))&amp;1)ip[tot]=1; else ip[tot]=0; ++tot; &#125; &#125;&#125;void change_binary()&#123;//将二进制变为点分十进制 for(int i=0;i&lt;4;++i)&#123; int x=0; for(int j=i*8;j&lt;(i+1)*8&amp;&amp;j&lt;subnet_len;++j)&#123; x=x|(ip[j]&lt;&lt;(7-j+i*8)); &#125; printf(\"%d\",x); if(i==3)&#123; if(subnet_len!=32)printf(\"/%d\\n\",subnet_len); else printf(\"\\n\"); &#125; else printf(\".\"); &#125;&#125;bool insert()&#123; node* p=root; if(subnet_len==0)&#123; if(white)&#123; if(p-&gt;has_black[0]||p-&gt;has_black[1]||p-&gt;all_black)return false; p-&gt;all_white=1; &#125; else&#123; if(p-&gt;has_white[0]||p-&gt;has_white[1]||p-&gt;all_white)return false; p-&gt;all_black=1; &#125; return 1; &#125; for(int i=0;i&lt;32;++i)&#123; if(white)p-&gt;has_white[ip[i]]=1; else p-&gt;has_black[ip[i]]=1; if(!p-&gt;next[ip[i]])p-&gt;next[ip[i]]=new node(); p=p-&gt;next[ip[i]]; if(p-&gt;all_white)&#123; if(white)break; return false;//黑白冲突 &#125; if(p-&gt;all_black)&#123; if(white)return false; break; &#125; if(i==subnet_len-1)&#123; if(white)&#123; p-&gt;all_white=1; if(p-&gt;has_black[0]||p-&gt;has_black[1])return false; &#125; else&#123; p-&gt;all_black=1; if(p-&gt;has_white[0]||p-&gt;has_white[1])return false; &#125; break; &#125; &#125; return 1;&#125;void dfs_num(node* now,int num)&#123; if(now-&gt;all_white)return; if(now-&gt;all_black|| (!now-&gt;has_white[0]&amp;&amp;!now-&gt;has_white[1]))&#123; ++ans; return; &#125; if(now-&gt;next[0])&#123; ip[num]=0; dfs_num(now-&gt;next[0],num+1); &#125; if(now-&gt;next[1])&#123; ip[num]=1; dfs_num(now-&gt;next[1],num+1); &#125;&#125;void dfs(node* now,int num)&#123; if(now-&gt;all_white)return; if(now-&gt;all_black || (!now-&gt;has_white[0]&amp;&amp;!now-&gt;has_white[1]))&#123; subnet_len=num; change_binary(); return; &#125; if(now-&gt;next[0])&#123; ip[num]=0; dfs(now-&gt;next[0],num+1); &#125; if(now-&gt;next[1])&#123; ip[num]=1; dfs(now-&gt;next[1],num+1); &#125;&#125;int main()&#123; root=new node(); int n;cin&gt;&gt;n; while(n--)&#123; scanf(\"%s\",buf); get_binary(); if(!insert())&#123; cout&lt;&lt;\"-1\"&lt;&lt;endl; return 0; &#125; &#125; if(black_num==0)&#123; cout&lt;&lt;\"-1\"&lt;&lt;endl; return 0; &#125; ans=0; dfs_num(root,0); cout&lt;&lt;ans&lt;&lt;endl; dfs(root,0); delete root; return 0;&#125; C. Cloud Computing pending D. Garbage Disposal 签到题一枚，题目大意是给你n天的每天的垃圾量，每个垃圾只能在当天或者第二天扔掉（不能放到第三天），垃圾只能装到包里才能扔，所以给你一个k，表示每个包最多能盛放多少垃圾。问最小需要多少个包。思路：直接贪心即可，每天把当天需要扔的垃圾整除k（装包扔掉），余数（即剩下不够装满一个包）就放到第二天扔。但是要注意垃圾不能存到第三天，所以只要保证当天扔的垃圾大于前一天剩下的即可。ac代码： 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;int main()&#123; long long n,k,last=0,a,ans=0,tmp; cin&gt;&gt;n&gt;&gt;k; while(n--)&#123; cin&gt;&gt;a; a+=last; tmp=a/k; a%=k; if(tmp*k&lt;last)&#123; //如果当天扔的小于昨天剩下的，也要强制扔去 ++tmp; a=0; &#125; ans+=tmp; last=a; &#125; if(last)++ans;//如果最后还剩下，就直接装包扔掉 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; E. Getting Deals Done pending F. Debate 题目大意：给你n（1","categories":[{"name":"平时训练の补题","slug":"平时训练の补题","permalink":"https://yanghaku.github.io/categories/%E5%B9%B3%E6%97%B6%E8%AE%AD%E7%BB%83%E3%81%AE%E8%A1%A5%E9%A2%98/"}],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"https://yanghaku.github.io/tags/codeforces/"}],"author":"yb"},{"title":"my first blog","slug":"my-first-blog","date":"2019-05-20T00:30:00.000Z","updated":"2019-05-20T00:52:33.000Z","comments":true,"path":"2019/05/20/my-first-blog/","link":"","permalink":"https://yanghaku.github.io/2019/05/20/my-first-blog/","excerpt":"从现在开始，2019.5.20，我将拥有自己的博客了。 对我来说写博客的用处有一下几点：","text":"从现在开始，2019.5.20，我将拥有自己的博客了。 对我来说写博客的用处有一下几点： 每天总结自己做过的题目，加深思考。 为自己写过的代码做备份，之前一直保存在本地，虽然都用文件夹做了分类，但是还是查找不方便，而且有时又懒得保存。 克服自己的懒惰，到了现在，看了自己的github，自己已经有半年没有好好写代码了，不仅仅是手懒，脑子也变得懒了，记得前几天教练还说过：我们已经停止了思考。对，就是停止了思考！现在的程度，是对许多的算法都知道，但是却不能静下心来仔细研究其中的原理和更深层的应用。没有了思考，也就没有了提高，只靠板子是做不了题的！ 所以从此，加油，克服自己的懒惰，才能提高！ 博客名字以后再想吧……","categories":[],"tags":[],"author":"yb"}]}